{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2023 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, isDevMode, Component, Optional, Input, Output, HostBinding, HostListener, ContentChildren, NgModule, Directive, InjectionToken, Inject, forwardRef, ElementRef, ViewContainerRef, ContentChild, ViewChild } from '@angular/core';\nimport { Subject, Subscription, fromEvent, merge } from 'rxjs';\nimport * as i9 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, isFirefox, Keys, isSafari, isChanged, hasObservers, guid, anyChanged, EventsModule } from '@progress/kendo-angular-common';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i2 from '@progress/kendo-angular-icons';\nimport { IconsModule } from '@progress/kendo-angular-icons';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { filter, tap, take } from 'rxjs/operators';\nimport * as i3$1 from '@progress/kendo-angular-popup';\nimport { PopupModule } from '@progress/kendo-angular-popup';\nimport { caretAltDownIcon, xCircleIcon } from '@progress/kendo-svg-icons';\nimport * as i4 from '@angular/animations';\nimport { sequence, query, style, stagger, animate } from '@angular/animations';\n\n/**\n * @hidden\n */\nconst _c0 = [\"kendoButton\", \"\"];\nfunction ButtonComponent_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction ButtonComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction ButtonComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c1 = [\"*\"];\nconst _c2 = [[[\"\", \"kendoButton\", \"\"], [\"kendo-button\"]]];\nconst _c3 = [\"[kendoButton], kendo-button\"];\nfunction ListComponent_li_1_ng_template_1_ng_template_1_Template(rf, ctx) {}\nconst _c4 = function (a0, a1) {\n  return {\n    templateRef: a0,\n    $implicit: a1\n  };\n};\nfunction ListComponent_li_1_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtemplate(1, ListComponent_li_1_ng_template_1_ng_template_1_Template, 0, 0, \"ng-template\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-disabled\", dataItem_r1.disabled);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(3, _c4, ctx_r3.itemTemplate == null ? null : ctx_r3.itemTemplate.templateRef, dataItem_r1));\n  }\n}\nfunction ListComponent_li_1_ng_template_2_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 9);\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵproperty(\"name\", dataItem_r1.icon)(\"svgIcon\", dataItem_r1.svgIcon)(\"customFontClass\", dataItem_r1.iconClass);\n  }\n}\nfunction ListComponent_li_1_ng_template_2_img_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 10);\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵproperty(\"src\", dataItem_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction ListComponent_li_1_ng_template_2_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r9.getText(dataItem_r1), \" \");\n  }\n}\nfunction ListComponent_li_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtemplate(1, ListComponent_li_1_ng_template_2_kendo_icon_wrapper_1_Template, 1, 3, \"kendo-icon-wrapper\", 6);\n    i0.ɵɵtemplate(2, ListComponent_li_1_ng_template_2_img_2_Template, 1, 1, \"img\", 7);\n    i0.ɵɵtemplate(3, ListComponent_li_1_ng_template_2_span_3_Template, 2, 1, \"span\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-disabled\", dataItem_r1.disabled);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", dataItem_r1.icon || dataItem_r1.iconClass || dataItem_r1.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", dataItem_r1.imageUrl);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.getText(dataItem_r1));\n  }\n}\nfunction ListComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 2);\n    i0.ɵɵlistener(\"click\", function ListComponent_li_1_Template_li_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r15);\n      const index_r2 = restoredCtx.index;\n      const ctx_r14 = i0.ɵɵnextContext();\n      $event.stopImmediatePropagation();\n      return i0.ɵɵresetView(ctx_r14.onClick(index_r2));\n    })(\"blur\", function ListComponent_li_1_Template_li_blur_0_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.onBlur());\n    });\n    i0.ɵɵtemplate(1, ListComponent_li_1_ng_template_1_Template, 2, 6, \"ng-template\", 3);\n    i0.ɵɵtemplate(2, ListComponent_li_1_ng_template_2_Template, 4, 5, \"ng-template\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = ctx.$implicit;\n    const index_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"index\", index_r2);\n    i0.ɵɵattribute(\"aria-disabled\", dataItem_r1.disabled ? true : false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.itemTemplate == null ? null : ctx_r0.itemTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(ctx_r0.itemTemplate == null ? null : ctx_r0.itemTemplate.templateRef));\n  }\n}\nconst _c5 = [\"button\"];\nconst _c6 = [\"arrowButton\"];\nconst _c7 = [\"popupTemplate\"];\nconst _c8 = [\"container\"];\nfunction SplitButtonComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.text, \" \");\n  }\n}\nfunction SplitButtonComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-button-list\", 10);\n    i0.ɵɵlistener(\"onItemClick\", function SplitButtonComponent_ng_template_8_Template_kendo_button_list_onItemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.onItemClick($event));\n    })(\"keydown\", function SplitButtonComponent_ng_template_8_Template_kendo_button_list_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.keyDownHandler($event));\n    })(\"keyup\", function SplitButtonComponent_ng_template_8_Template_kendo_button_list_keyup_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.keyUpHandler($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r4.listId)(\"data\", ctx_r4.data)(\"textField\", ctx_r4.textField)(\"itemTemplate\", ctx_r4.itemTemplate)(\"size\", ctx_r4.size);\n    i0.ɵɵattribute(\"dir\", ctx_r4.dir);\n  }\n}\nconst _c11 = [\"buttonList\"];\nfunction DropDownButtonComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-button-list\", 4, 5);\n    i0.ɵɵlistener(\"onItemClick\", function DropDownButtonComponent_ng_template_3_Template_kendo_button_list_onItemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.onItemClick($event));\n    })(\"keydown\", function DropDownButtonComponent_ng_template_3_Template_kendo_button_list_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.keyDownHandler($event));\n    })(\"keyup\", function DropDownButtonComponent_ng_template_3_Template_kendo_button_list_keyup_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.keyUpHandler($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r2.listId)(\"data\", ctx_r2.data)(\"textField\", ctx_r2.textField)(\"itemTemplate\", ctx_r2.itemTemplate)(\"size\", ctx_r2.size);\n    i0.ɵɵattribute(\"dir\", ctx_r2.dir)(\"aria-labelledby\", ctx_r2.buttonId);\n  }\n}\nfunction ChipComponent_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction ChipComponent_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"customFontClass\", ctx_r1.customIconClass);\n  }\n}\nfunction ChipComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.chipAvatarClass);\n  }\n}\nfunction ChipComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.label, \" \");\n  }\n}\nfunction ChipComponent_ng_content_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!label\"]);\n  }\n}\nfunction ChipComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 13);\n    i0.ɵɵlistener(\"click\", function ChipComponent_span_7_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.onRemoveClick($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 14);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r5.defaultRemoveIcon || ctx_r5.removeSvgIcon)(\"customFontClass\", ctx_r5.removeIcon);\n  }\n}\nconst _c12 = [\"kendoDialItem\", \"\"];\nfunction DialItemComponent_0_ng_template_0_Template(rf, ctx) {}\nconst _c13 = function (a0, a1, a2) {\n  return {\n    $implicit: a0,\n    index: a1,\n    isFocused: a2\n  };\n};\nfunction DialItemComponent_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DialItemComponent_0_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.dialItemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(2, _c13, ctx_r0.item, ctx_r0.index, ctx_r0.isFocused));\n  }\n}\nfunction DialItemComponent_ng_container_1_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.item.label);\n  }\n}\nfunction DialItemComponent_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"name\", ctx_r4.item.icon)(\"customFontClass\", ctx_r4.item.iconClass)(\"svgIcon\", ctx_r4.item.svgIcon);\n  }\n}\nfunction DialItemComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, DialItemComponent_ng_container_1_span_1_Template, 2, 1, \"span\", 2);\n    i0.ɵɵtemplate(2, DialItemComponent_ng_container_1_kendo_icon_wrapper_2_Template, 1, 3, \"kendo-icon-wrapper\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.item.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.item.icon || ctx_r1.item.iconClass || ctx_r1.item.svgIcon);\n  }\n}\nconst _c14 = [\"kendoDialList\", \"\"];\nfunction DialListComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"li\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const idx_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"item\", ctx_r0.dialItems[idx_r2])(\"index\", idx_r2)(\"dialItemTemplate\", ctx_r0.dialItemTemplate)(\"isFocused\", ctx_r0.isFocused(idx_r2))(\"ngClass\", item_r1.cssClass)(\"ngStyle\", item_r1.cssStyle)(\"align\", ctx_r0.align);\n  }\n}\nfunction FloatingActionButtonComponent_2_ng_template_0_Template(rf, ctx) {}\nfunction FloatingActionButtonComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, FloatingActionButtonComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.fabTemplate == null ? null : ctx_r1.fabTemplate.templateRef);\n  }\n}\nfunction FloatingActionButtonComponent_ng_container_3_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"name\", ctx_r6.icon)(\"customFontClass\", ctx_r6.iconClass)(\"svgIcon\", ctx_r6.svgIcon);\n  }\n}\nfunction FloatingActionButtonComponent_ng_container_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r7.text);\n  }\n}\nfunction FloatingActionButtonComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, FloatingActionButtonComponent_ng_container_3_kendo_icon_wrapper_1_Template, 1, 3, \"kendo-icon-wrapper\", 5);\n    i0.ɵɵtemplate(2, FloatingActionButtonComponent_ng_container_3_span_2_Template, 2, 1, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.icon || ctx_r2.iconClass || ctx_r2.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.text);\n  }\n}\nfunction FloatingActionButtonComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"ul\", 9);\n    i0.ɵɵlistener(\"click\", function FloatingActionButtonComponent_ng_template_4_Template_ul_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.onItemClick($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r4.dialListId)(\"ngClass\", ctx_r4.dialClass)(\"dialItems\", ctx_r4.dialItems)(\"dialItemTemplate\", ctx_r4.dialItemTemplate == null ? null : ctx_r4.dialItemTemplate.templateRef)(\"align\", ctx_r4.align);\n    i0.ɵɵattribute(\"aria-labelledby\", ctx_r4.id);\n  }\n}\nconst _c15 = function (a0, a1) {\n  return {\n    keydown: a0,\n    click: a1\n  };\n};\nlet KendoButtonService = /*#__PURE__*/(() => {\n  class KendoButtonService {\n    constructor() {\n      this.buttonClicked = new Subject();\n      this.buttonClicked$ = this.buttonClicked.asObservable();\n    }\n    click(button) {\n      this.buttonClicked.next(button);\n    }\n  }\n  KendoButtonService.ɵfac = function KendoButtonService_Factory(t) {\n    return new (t || KendoButtonService)();\n  };\n  KendoButtonService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: KendoButtonService,\n    factory: KendoButtonService.ɵfac\n  });\n  return KendoButtonService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n  name: '@progress/kendo-angular-buttons',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1694532892,\n  version: '13.5.0',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * @hidden\n */\nconst resolvedPromise = Promise.resolve(null);\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst tick = f => resolvedPromise.then(f);\n/**\n * @hidden\n */\nfunction isDocumentNode(container) {\n  return container.nodeType === 9;\n}\n/**\n * @hidden\n */\nfunction closest(element, selector) {\n  if (element.closest) {\n    return element.closest(selector);\n  }\n  const matches = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);\n  let node = element;\n  while (node && !isDocumentNode(node)) {\n    if (matches(node, selector)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n}\n/**\n * @hidden\n */\nconst replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`\\{\\\\s*${name}\\\\s*\\}`, 'g'), value);\n/**\n * @hidden\n */\nconst SIZES = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg'\n};\nconst ROUNDNESS = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg',\n  full: 'full'\n};\n/**\n * @hidden\n *\n * Returns the styling classes to be added and removed\n */\nconst getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {\n  switch (stylingOption) {\n    case 'size':\n      return {\n        toRemove: `k-${componentType}-${SIZES[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''\n      };\n    case 'rounded':\n      return {\n        toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-rounded-${ROUNDNESS[newValue]}` : ''\n      };\n    case 'fillMode':\n      return {\n        toRemove: `k-${componentType}-${previousValue}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${newValue}` : ''\n      };\n    default:\n      break;\n  }\n};\n/**\n * @hidden\n *\n * Returns the themeColor classes to be added and removed\n */\nconst getThemeColorClasses = (componentType, prevFillMode, fillMode, previousValue, newValue) => {\n  return {\n    toRemove: `k-${componentType}-${prevFillMode}-${previousValue}`,\n    toAdd: newValue !== 'none' ? `k-${componentType}-${fillMode}-${newValue}` : ''\n  };\n};\nconst SPAN_TAG_NAME = 'SPAN';\nconst BUTTON_TAG_NAME = 'BUTTON';\nconst KENDO_BUTTON_TAG_NAME = 'KENDO-BUTTON';\nconst DEFAULT_ROUNDED$3 = 'medium';\nconst DEFAULT_SIZE$2 = 'medium';\nconst DEFAULT_THEME_COLOR$2 = 'base';\nconst DEFAULT_FILL_MODE$3 = 'solid';\n/**\n * Represents the Kendo UI Button component for Angular.\n */\nlet ButtonComponent = /*#__PURE__*/(() => {\n  class ButtonComponent {\n    constructor(element, renderer, service, localization, ngZone) {\n      this.renderer = renderer;\n      this.service = service;\n      this.ngZone = ngZone;\n      /**\n       * Provides visual styling that indicates if the Button is active.\n       *\n       * @default false\n       */\n      this.toggleable = false;\n      /**\n       * @hidden\n       */\n      this.role = 'button';\n      /**\n       * Fires each time the selected state of a toggleable button is changed.\n       *\n       * The event argument is the new selected state (boolean).\n       */\n      this.selectedChange = new EventEmitter();\n      /**\n       * Fires each time the user clicks the button.\n       */\n      this.click = new EventEmitter();\n      this.isDisabled = false;\n      this._size = DEFAULT_SIZE$2;\n      this._rounded = DEFAULT_ROUNDED$3;\n      this._fillMode = DEFAULT_FILL_MODE$3;\n      this._themeColor = DEFAULT_THEME_COLOR$2;\n      this._focused = false;\n      this.subs = new Subscription();\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subs.add(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.element = element.nativeElement;\n    }\n    /**\n     * Backwards-compatible alias\n     *\n     * @hidden\n     */\n    get togglable() {\n      return this.toggleable;\n    }\n    /**\n     * @hidden\n     */\n    set togglable(value) {\n      this.toggleable = value;\n    }\n    /**\n     * Sets the selected state of the Button.\n     *\n     * @default false\n     */\n    get selected() {\n      return this._selected || false;\n    }\n    set selected(value) {\n      this._selected = value;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(index) {\n      this.element.tabIndex = index;\n    }\n    get tabIndex() {\n      return this.element.tabIndex;\n    }\n    /**\n     * Defines a CSS class&mdash;or multiple classes separated by spaces&mdash;\n     * which are applied to a `span` element inside the Button. Allows the usage of custom icons.\n     */\n    set iconClass(value) {\n      if (isDevMode() && value && (this.icon || this.svgIcon)) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._iconClass = value;\n    }\n    get iconClass() {\n      return this._iconClass;\n    }\n    /**\n     * Defines the name for an existing font icon in the Kendo UI theme.\n     */\n    set icon(name) {\n      if (isDevMode() && name && this.iconClass) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._icon = name;\n    }\n    get icon() {\n      return this._icon;\n    }\n    /**\n     * If set to `true`, it disables the Button.\n     *\n     * @default false\n     */\n    set disabled(disabled) {\n      //Required, because in FF focused buttons are not blurred on disabled\n      if (disabled && isDocumentAvailable() && isFirefox(navigator.userAgent)) {\n        this.blur();\n      }\n      this.isDisabled = disabled;\n      this.renderer.setProperty(this.element, 'disabled', disabled);\n    }\n    get disabled() {\n      return this.isDisabled;\n    }\n    /**\n     * The size property specifies the padding of the Button\n     * ([see example]({% slug appearance_button %}#toc-size)).\n     *\n     * @default 'medium'\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$2;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the Button\n     * ([see example]({% slug appearance_button %}#toc-rounded)).\n     *\n     * @default 'medium'\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$3;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the Button\n     * ([see example]({% slug appearance_button %}#toc-fillMode)).\n     *\n     * @default 'solid'\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$3;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The Button allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color while also amending the text color accordingly\n     * ([see example]({% slug appearance_button %}#toc-themeColor)).\n     *\n     * @default 'base'\n     */\n    set themeColor(themeColor) {\n      const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR$2;\n      this.handleThemeColor(newThemeColor);\n      this._themeColor = newThemeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * Defines an SVGIcon to be rendered within the button.\n     */\n    set svgIcon(icon) {\n      if (isDevMode() && icon && this.iconClass) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._svgIcon = icon;\n    }\n    get svgIcon() {\n      return this._svgIcon;\n    }\n    set isFocused(isFocused) {\n      this.toggleClass('k-focus', isFocused);\n      this._focused = isFocused;\n    }\n    get isFocused() {\n      return this._focused;\n    }\n    get classButton() {\n      return true;\n    }\n    get isToggleable() {\n      return this.toggleable;\n    }\n    get iconButtonClass() {\n      const hasIcon = this.icon || this.iconClass || this.imageUrl || this.svgIcon;\n      return hasIcon && !this.hasText;\n    }\n    get roleSetter() {\n      return this.role;\n    }\n    get classDisabled() {\n      return this.isDisabled;\n    }\n    get classActive() {\n      return this.selected;\n    }\n    get getDirection() {\n      return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    onFocus() {\n      this.isFocused = true;\n    }\n    /**\n     * @hidden\n     */\n    onBlur() {\n      this.isFocused = false;\n    }\n    /**\n     * @hidden\n     */\n    set primary(value) {\n      this.themeColor = value ? 'primary' : 'base';\n    }\n    /**\n     * @hidden\n     */\n    set look(value) {\n      switch (value) {\n        case 'default':\n          this.fillMode = 'solid';\n          break;\n        default:\n          this.fillMode = value;\n          break;\n      }\n    }\n    /**\n     * Alias for ElementRef.nativeElement to workaround\n     * ViewChild() selectors that used to return the host element before v11.\n     *\n     * @hidden\n     */\n    get nativeElement() {\n      return this.element;\n    }\n    ngOnInit() {\n      const elementTagName = this.element.tagName;\n      const isSpanOrKendoButton = elementTagName === SPAN_TAG_NAME || elementTagName === KENDO_BUTTON_TAG_NAME;\n      if (!this.element.hasAttribute('role') && this.togglable) {\n        this.toggleAriaPressed(this.toggleable);\n      }\n      if (this.role) {\n        this.setAttribute('role', this.role);\n      }\n      if (isSpanOrKendoButton && !this.isDisabled) {\n        this.tabIndex = 0;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(this.element, 'click', this._onButtonClick.bind(this)));\n        this.subs.add(this.renderer.listen(this.element, 'keydown', event => {\n          const isSpaceOrEnter = event.keyCode === Keys.Space || event.keyCode === Keys.Enter;\n          if (isSpanOrKendoButton && isSpaceOrEnter) {\n            this.ngZone.run(() => {\n              this.click.emit(event);\n            });\n            this._onButtonClick();\n          }\n        }));\n        this.subs.add(this.renderer.listen(this.element, 'mousedown', event => {\n          const elementTagName = this.element.tagName;\n          const isButton = elementTagName === BUTTON_TAG_NAME;\n          const isBrowserSafari = isDocumentAvailable() && isSafari(navigator.userAgent);\n          if (!this.isDisabled && isButton && isBrowserSafari) {\n            event.preventDefault();\n            this.element.focus();\n          }\n        }));\n      });\n    }\n    ngOnChanges(change) {\n      if (isChanged('togglable', change) || isChanged('toggleable', change)) {\n        this.toggleAriaPressed(this.toggleable);\n      }\n    }\n    ngAfterViewInit() {\n      const stylingOptions = ['size', 'rounded', 'fillMode'];\n      stylingOptions.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    get hasText() {\n      return isDocumentAvailable() && this.element.textContent.trim().length > 0;\n    }\n    /**\n     * Focuses the Button component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.element.focus();\n        this.isFocused = true;\n      }\n    }\n    /**\n     * Blurs the Button component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.element.blur();\n        this.isFocused = false;\n      }\n    }\n    /**\n     * @hidden\n     */\n    setAttribute(attribute, value) {\n      this.renderer.setAttribute(this.element, attribute, value);\n    }\n    /**\n     * @hidden\n     */\n    removeAttribute(attribute) {\n      this.renderer.removeAttribute(this.element, attribute);\n    }\n    /**\n     * @hidden\n     *\n     * Internal setter that triggers selectedChange\n     */\n    setSelected(value) {\n      const changed = this.selected !== value;\n      this.selected = value;\n      this.setAttribute('aria-pressed', this.selected.toString());\n      this.toggleClass('k-selected', this.selected);\n      if (changed && hasObservers(this.selectedChange)) {\n        this.ngZone.run(() => {\n          this.selectedChange.emit(value);\n        });\n      }\n    }\n    toggleAriaPressed(shouldSet) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (shouldSet) {\n        this.setAttribute('aria-pressed', this.selected.toString());\n      } else {\n        this.removeAttribute('aria-pressed');\n      }\n    }\n    toggleClass(className, add) {\n      if (add) {\n        this.renderer.addClass(this.element, className);\n      } else {\n        this.renderer.removeClass(this.element, className);\n      }\n    }\n    _onButtonClick() {\n      if (!this.disabled && this.service) {\n        this.ngZone.run(() => {\n          this.service.click(this);\n        });\n      }\n      if (this.togglable && !this.service) {\n        this.setSelected(!this.selected);\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.element;\n      const classes = getStylingClasses('button', input, this[input], value);\n      if (input === 'fillMode') {\n        this.handleThemeColor(this.themeColor, this[input], value);\n      }\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    handleThemeColor(value, prevFillMode, fillMode) {\n      const elem = this.element;\n      const removeFillMode = prevFillMode ? prevFillMode : this.fillMode;\n      const addFillMode = fillMode ? fillMode : this.fillMode;\n      const themeColorClass = getThemeColorClasses('button', removeFillMode, addFillMode, this.themeColor, value);\n      this.renderer.removeClass(elem, themeColorClass.toRemove);\n      if (addFillMode !== 'none' && fillMode !== 'none') {\n        if (themeColorClass.toAdd) {\n          this.renderer.addClass(elem, themeColorClass.toAdd);\n        }\n      }\n    }\n  }\n  ButtonComponent.ɵfac = function ButtonComponent_Factory(t) {\n    return new (t || ButtonComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(KendoButtonService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  ButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ButtonComponent,\n    selectors: [[\"button\", \"kendoButton\", \"\"], [\"span\", \"kendoButton\", \"\"], [\"kendo-button\"]],\n    hostVars: 13,\n    hostBindings: function ButtonComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function ButtonComponent_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function ButtonComponent_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.roleSetter)(\"aria-disabled\", ctx.classDisabled)(\"dir\", ctx.getDirection);\n        i0.ɵɵclassProp(\"k-button\", ctx.classButton)(\"k-toggle-button\", ctx.isToggleable)(\"k-icon-button\", ctx.iconButtonClass)(\"k-disabled\", ctx.classDisabled)(\"k-selected\", ctx.classActive);\n      }\n    },\n    inputs: {\n      toggleable: \"toggleable\",\n      togglable: \"togglable\",\n      selected: \"selected\",\n      tabIndex: \"tabIndex\",\n      imageUrl: \"imageUrl\",\n      iconClass: \"iconClass\",\n      icon: \"icon\",\n      disabled: \"disabled\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      svgIcon: \"svgIcon\",\n      role: \"role\",\n      primary: \"primary\",\n      look: \"look\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      click: \"click\"\n    },\n    exportAs: [\"kendoButton\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵNgOnChangesFeature],\n    attrs: _c0,\n    ngContentSelectors: _c1,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function ButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, ButtonComponent_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, ButtonComponent_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, ButtonComponent_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [i2.IconWrapperComponent, i3.NgIf, i3.NgClass],\n    encapsulation: 2\n  });\n  return ButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n}\n\n/**\n * @hidden\n */\nconst tabindex = 'tabindex';\n/**\n * Represents the Kendo UI ButtonGroup component for Angular.\n */\nlet ButtonGroupComponent = /*#__PURE__*/(() => {\n  class ButtonGroupComponent {\n    constructor(service, localization, element) {\n      this.service = service;\n      this.element = element;\n      /**\n       * The selection mode of the ButtonGroup.\n       * @default 'multiple'\n       */\n      this.selection = 'multiple';\n      /**\n       * When this option is set to `true` (default), the component is a single tab-stop,\n       * and focus is moved through the inner buttons via the arrow keys.\n       *\n       * When the option is set to `false`, the inner buttons are part of the natural tab sequence of the page.\n       *\n       * @default true\n       */\n      this.navigable = true;\n      /**\n       * Fires every time keyboard navigation occurs.\n       */\n      this.navigate = new EventEmitter();\n      this._tabIndex = 0;\n      this.currentTabIndex = 0;\n      this.subs = new Subscription();\n      this.role = 'group';\n      this.focusHandler = () => {\n        this.currentTabIndex = -1;\n        const focusedIndex = this.buttons.toArray().findIndex(current => current.element.tabIndex !== -1);\n        const index = focusedIndex === -1 ? 0 : focusedIndex;\n        this.focus(this.buttons.filter((_current, i) => {\n          return i === index;\n        }));\n      };\n      validatePackage(packageMetadata);\n      this.subs.add(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n    }\n    /**\n     * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabIndex(value) {\n      this._tabIndex = value;\n      this.currentTabIndex = value;\n    }\n    get tabIndex() {\n      return this._tabIndex;\n    }\n    get wrapperClass() {\n      return true;\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    get stretchedClass() {\n      return !!this.width;\n    }\n    get dir() {\n      return this.direction;\n    }\n    get ariaDisabled() {\n      return this.disabled;\n    }\n    get wrapperWidth() {\n      return this.width;\n    }\n    get wrapperTabIndex() {\n      return this.disabled ? undefined : this.navigable ? this.currentTabIndex : undefined;\n    }\n    ngOnInit() {\n      this.subs.add(this.service.buttonClicked$.subscribe(button => {\n        let newSelectionValue;\n        if (this.isSelectionSingle()) {\n          newSelectionValue = true;\n          this.deactivate(this.buttons.filter(current => current !== button));\n        } else {\n          if (this.navigable) {\n            this.defocus(this.buttons.toArray());\n          }\n          newSelectionValue = !button.selected;\n        }\n        if (button.togglable) {\n          button.setSelected(newSelectionValue);\n        }\n        if (this.navigable) {\n          button.setAttribute(tabindex, '0');\n        }\n      }));\n      this.handleSubs('focus', () => this.navigable, this.focusHandler);\n      this.handleSubs('keydown', () => this.navigable && !this.disabled, event => this.navigateFocus(event));\n      this.handleSubs('focusout', event => this.navigable && event.relatedTarget && event.relatedTarget.parentNode !== this.element.nativeElement, () => {\n        this.defocus(this.buttons.toArray());\n        this.currentTabIndex = this.tabIndex;\n      });\n      this.subs.add(fromEvent(this.element.nativeElement, 'focusout').pipe(filter(event => this.navigable && event.relatedTarget && event.relatedTarget.parentNode !== this.element.nativeElement)).subscribe(() => {\n        this.defocus(this.buttons.toArray());\n        this.currentTabIndex = this.tabIndex;\n      }));\n    }\n    ngOnChanges(changes) {\n      if (isChanged('disabled', changes)) {\n        this.buttons.forEach(button => {\n          if (isPresent(this.disabled)) {\n            button.disabled = this.disabled;\n          }\n        });\n      }\n      if (isChanged('navigable', changes)) {\n        if (changes['navigable'].currentValue) {\n          this.setButtonsTabIndex();\n          this.currentTabIndex = 0;\n        } else {\n          this.currentTabIndex = -1;\n          this.buttons.forEach(button => button.setAttribute(tabindex, '0'));\n        }\n      }\n    }\n    ngAfterContentInit() {\n      if (!this.navigable) {\n        return;\n      }\n      this.setButtonsTabIndex();\n    }\n    ngAfterViewChecked() {\n      if (this.buttons.length) {\n        this.buttons.first.renderer.addClass(this.buttons.first.element, 'k-group-start');\n        this.buttons.last.renderer.addClass(this.buttons.last.element, 'k-group-end');\n      }\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    navigateFocus(event) {\n      const focusedIndex = this.buttons.toArray().findIndex(current => current.element.tabIndex !== -1);\n      const firstIndex = 0;\n      const lastIndex = this.buttons.length - 1;\n      const eventArgs = new PreventableEvent();\n      if (event.keyCode === Keys.ArrowRight && focusedIndex < lastIndex) {\n        this.navigate.emit(eventArgs);\n        if (!eventArgs.isDefaultPrevented()) {\n          this.defocus(this.buttons.toArray());\n          this.focus(this.buttons.filter((_current, index) => {\n            return index === focusedIndex + 1;\n          }));\n        }\n      }\n      if (event.keyCode === Keys.ArrowLeft && focusedIndex > firstIndex) {\n        this.navigate.emit(eventArgs);\n        if (!eventArgs.isDefaultPrevented()) {\n          this.defocus(this.buttons.toArray());\n          this.focus(this.buttons.filter((_current, index) => {\n            return index === focusedIndex - 1;\n          }));\n        }\n      }\n    }\n    deactivate(buttons) {\n      buttons.forEach(button => {\n        button.setSelected(false);\n        if (this.navigable) {\n          button.setAttribute(tabindex, '-1');\n        }\n      });\n    }\n    activate(buttons) {\n      buttons.forEach(button => {\n        button.setSelected(true);\n        if (this.navigable) {\n          button.setAttribute(tabindex, '0');\n        }\n        button.focus();\n      });\n    }\n    defocus(buttons) {\n      buttons.forEach(button => {\n        button.setAttribute(tabindex, '-1');\n      });\n    }\n    focus(buttons) {\n      buttons.forEach(button => {\n        button.setAttribute(tabindex, '0');\n        button.focus();\n      });\n    }\n    verifySettings() {\n      if (isDevMode()) {\n        if (this.isSelectionSingle() && this.buttons.filter(button => button.selected).length > 1) {\n          throw new Error('Having multiple selected buttons with single selection mode is not supported');\n        }\n      }\n    }\n    isSelectionSingle() {\n      return this.selection === 'single';\n    }\n    setButtonsTabIndex() {\n      this.buttons.forEach(button => {\n        if (button.selected) {\n          button.setAttribute(tabindex, '0');\n        } else {\n          button.setAttribute(tabindex, '-1');\n        }\n      });\n    }\n    handleSubs(eventName, predicate, handler) {\n      this.subs.add(fromEvent(this.element.nativeElement, eventName).pipe(filter(predicate)).subscribe(handler));\n    }\n  }\n  ButtonGroupComponent.ɵfac = function ButtonGroupComponent_Factory(t) {\n    return new (t || ButtonGroupComponent)(i0.ɵɵdirectiveInject(KendoButtonService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  ButtonGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ButtonGroupComponent,\n    selectors: [[\"kendo-buttongroup\"]],\n    contentQueries: function ButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ButtonComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttons = _t);\n      }\n    },\n    hostVars: 12,\n    hostBindings: function ButtonGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"dir\", ctx.dir)(\"aria-disabled\", ctx.ariaDisabled)(\"tabindex\", ctx.wrapperTabIndex);\n        i0.ɵɵstyleProp(\"width\", ctx.wrapperWidth);\n        i0.ɵɵclassProp(\"k-button-group\", ctx.wrapperClass)(\"k-disabled\", ctx.disabledClass)(\"k-button-group-stretched\", ctx.stretchedClass);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      selection: \"selection\",\n      width: \"width\",\n      tabIndex: \"tabIndex\",\n      navigable: \"navigable\"\n    },\n    outputs: {\n      navigate: \"navigate\"\n    },\n    exportAs: [\"kendoButtonGroup\"],\n    features: [i0.ɵɵProvidersFeature([KendoButtonService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.buttongroup'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c3,\n    decls: 1,\n    vars: 0,\n    template: function ButtonGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c2);\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ButtonGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmodules'])\n * definition for the Button directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Button module\n * import { ButtonModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ButtonModule], // import Button module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet ButtonModule = /*#__PURE__*/(() => {\n  class ButtonModule {}\n  ButtonModule.ɵfac = function ButtonModule_Factory(t) {\n    return new (t || ButtonModule)();\n  };\n  ButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ButtonModule\n  });\n  ButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IconsModule]]\n  });\n  return ButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `ButtonGroupComponent`&mdash;The ButtonGroupComponent component class.\n */\nlet ButtonGroupModule = /*#__PURE__*/(() => {\n  class ButtonGroupModule {}\n  ButtonGroupModule.ɵfac = function ButtonGroupModule_Factory(t) {\n    return new (t || ButtonGroupModule)();\n  };\n  ButtonGroupModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ButtonGroupModule\n  });\n  ButtonGroupModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, ButtonModule]]\n  });\n  return ButtonGroupModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Used for rendering the list item content.\n *\n * To define the item template, nest a `<ng-template>` tag with the `kendo<ComponentName>ItemTemplate` directive inside the component tag.\n *\n * For the DropDownButton, use the `kendoDropDownButtonItemTemplate` directive.\n * For the SplitButton, use the `kendoSplitButtonItemTemplate` directive.\n *\n * The template context is set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-splitbutton [data]=\"listItems\">\n *    <ng-template kendoSplitButtonItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-splitbutton>\n *  <kendo-dropdownbutton [data]=\"listItems\">\n *    <ng-template kendoDropDownButtonItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-dropdownbutton>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<any> = [{\n *      text: 'item1',\n *      icon: 'arrow-rotate-cw',\n *      disabled: false,\n *      click: (dataItem: any) => {\n *          //action\n *      }\n *  }, {\n *      text: 'item2',\n *      icon: 'arrow-rotate-cw',\n *      disabled: false,\n *      click: (dataItem: any) => {\n *          //action\n *      }\n *  }]\n * }\n * ```\n *\n * For more examples, refer to the article on the [DropDownList templates]({% slug overview_ddl %}#templates).\n */\nlet ButtonItemTemplateDirective = /*#__PURE__*/(() => {\n  class ButtonItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n  }\n  ButtonItemTemplateDirective.ɵfac = function ButtonItemTemplateDirective_Factory(t) {\n    return new (t || ButtonItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  ButtonItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ButtonItemTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownButtonItemTemplate\", \"\"], [\"\", \"kendoSplitButtonItemTemplate\", \"\"]]\n  });\n  return ButtonItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FocusService = /*#__PURE__*/(() => {\n  class FocusService {\n    constructor() {\n      this.onFocus = new EventEmitter();\n    }\n    isFocused(index) {\n      return index === this.focused;\n    }\n    focus(index) {\n      if (this.isFocused(index)) {\n        return;\n      }\n      this.focused = index;\n      this.onFocus.emit(index);\n    }\n    resetFocus() {\n      this.focused = -1;\n    }\n    get focused() {\n      return this.focusedIndex;\n    }\n    set focused(index) {\n      this.focusedIndex = index;\n      this.onFocus.emit(index);\n    }\n  }\n  FocusService.ɵfac = function FocusService_Factory(t) {\n    return new (t || FocusService)();\n  };\n  FocusService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FocusService,\n    factory: FocusService.ɵfac\n  });\n  return FocusService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FocusableDirective = /*#__PURE__*/(() => {\n  class FocusableDirective {\n    constructor(focusService, elementRef, renderer) {\n      this.focusService = focusService;\n      this.renderer = renderer;\n      this.subs = new Subscription();\n      this.element = elementRef.nativeElement;\n      this.subscribeEvents();\n    }\n    ngOnInit() {\n      if (this.index === this.focusService.focused) {\n        this.renderer.addClass(this.element, 'k-focus');\n      } else {\n        this.renderer.removeClass(this.element, 'k-focus');\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subs.add(this.focusService.onFocus.subscribe(index => {\n        if (this.index === index) {\n          this.renderer.addClass(this.element, 'k-focus');\n          this.renderer.setAttribute(this.element, 'tabidnex', '0');\n          this.element.focus();\n        } else {\n          this.renderer.setAttribute(this.element, 'tabidnex', '-1');\n          this.renderer.removeClass(this.element, 'k-focus');\n        }\n      }));\n    }\n  }\n  FocusableDirective.ɵfac = function FocusableDirective_Factory(t) {\n    return new (t || FocusableDirective)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  FocusableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusableDirective,\n    selectors: [[\"\", \"kendoButtonFocusable\", \"\"]],\n    inputs: {\n      index: \"index\"\n    }\n  });\n  return FocusableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TemplateContextDirective = /*#__PURE__*/(() => {\n  class TemplateContextDirective {\n    constructor(viewContainerRef) {\n      this.viewContainerRef = viewContainerRef;\n    }\n    set templateContext(context) {\n      if (this.insertedViewRef) {\n        this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));\n        this.insertedViewRef = undefined;\n      }\n      if (context.templateRef) {\n        this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n      }\n    }\n  }\n  TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) {\n    return new (t || TemplateContextDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  TemplateContextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TemplateContextDirective,\n    selectors: [[\"\", \"templateContext\", \"\"]],\n    inputs: {\n      templateContext: \"templateContext\"\n    }\n  });\n  return TemplateContextDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ListComponent = /*#__PURE__*/(() => {\n  class ListComponent {\n    constructor() {\n      this.onItemClick = new EventEmitter();\n      this.onItemBlur = new EventEmitter();\n      this.sizeClass = '';\n      validatePackage(packageMetadata);\n    }\n    set size(size) {\n      if (size) {\n        this.sizeClass = `k-menu-group-${SIZES[size]}`;\n      } else {\n        this.sizeClass = '';\n      }\n    }\n    getText(dataItem) {\n      if (dataItem) {\n        return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;\n      }\n      return undefined;\n    }\n    getIconClasses(dataItem) {\n      const icon = dataItem.icon ? 'k-icon k-i-' + dataItem.icon : undefined;\n      const classes = {};\n      classes[icon || dataItem.iconClass] = true;\n      return classes;\n    }\n    onClick(index) {\n      this.onItemClick.emit(index);\n    }\n    onBlur() {\n      this.onItemBlur.emit();\n    }\n  }\n  ListComponent.ɵfac = function ListComponent_Factory(t) {\n    return new (t || ListComponent)();\n  };\n  ListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ListComponent,\n    selectors: [[\"kendo-button-list\"]],\n    inputs: {\n      data: \"data\",\n      textField: \"textField\",\n      itemTemplate: \"itemTemplate\",\n      size: \"size\"\n    },\n    outputs: {\n      onItemClick: \"onItemClick\",\n      onItemBlur: \"onItemBlur\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"unselectable\", \"on\", \"role\", \"menu\", 1, \"k-group\", \"k-menu-group\", \"k-reset\", 3, \"ngClass\"], [\"role\", \"menuitem\", \"unselectable\", \"on\", \"kendoButtonFocusable\", \"\", \"tabindex\", \"-1\", \"class\", \"k-item k-menu-item\", 3, \"index\", \"click\", \"blur\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"menuitem\", \"unselectable\", \"on\", \"kendoButtonFocusable\", \"\", \"tabindex\", \"-1\", 1, \"k-item\", \"k-menu-item\", 3, \"index\", \"click\", \"blur\"], [3, \"ngIf\"], [1, \"k-link\", \"k-menu-link\"], [3, \"templateContext\"], [3, \"name\", \"svgIcon\", \"customFontClass\", 4, \"ngIf\"], [\"class\", \"k-image\", \"alt\", \"\", 3, \"src\", 4, \"ngIf\"], [\"class\", \"k-menu-link-text\", 4, \"ngIf\"], [3, \"name\", \"svgIcon\", \"customFontClass\"], [\"alt\", \"\", 1, \"k-image\", 3, \"src\"], [1, \"k-menu-link-text\"]],\n    template: function ListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵtemplate(1, ListComponent_li_1_Template, 3, 4, \"li\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.sizeClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.data);\n      }\n    },\n    dependencies: [i2.IconWrapperComponent, i3.NgClass, i3.NgForOf, FocusableDirective, i3.NgIf, TemplateContextDirective],\n    encapsulation: 2\n  });\n  return ListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EXPORTED_DIRECTIVES = [ListComponent, FocusableDirective, ButtonItemTemplateDirective, TemplateContextDirective];\n/**\n * @hidden\n */\nlet ListModule = /*#__PURE__*/(() => {\n  class ListModule {}\n  ListModule.ɵfac = function ListModule_Factory(t) {\n    return new (t || ListModule)();\n  };\n  ListModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ListModule\n  });\n  ListModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IconsModule]]\n  });\n  return ListModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nvar KeyEvents = /*#__PURE__*/(() => {\n  (function (KeyEvents) {\n    KeyEvents[KeyEvents[\"keydown\"] = 0] = \"keydown\";\n    KeyEvents[KeyEvents[\"keypress\"] = 1] = \"keypress\";\n    KeyEvents[KeyEvents[\"keyup\"] = 2] = \"keyup\";\n  })(KeyEvents || (KeyEvents = {}));\n  return KeyEvents;\n})();\n/**\n * @hidden\n */\nvar NavigationAction = /*#__PURE__*/(() => {\n  (function (NavigationAction) {\n    // eslint-disable-next-line id-denylist\n    NavigationAction[NavigationAction[\"Undefined\"] = 0] = \"Undefined\";\n    NavigationAction[NavigationAction[\"Open\"] = 1] = \"Open\";\n    NavigationAction[NavigationAction[\"Close\"] = 2] = \"Close\";\n    NavigationAction[NavigationAction[\"Enter\"] = 3] = \"Enter\";\n    NavigationAction[NavigationAction[\"EnterPress\"] = 4] = \"EnterPress\";\n    NavigationAction[NavigationAction[\"EnterUp\"] = 5] = \"EnterUp\";\n    NavigationAction[NavigationAction[\"Tab\"] = 6] = \"Tab\";\n    NavigationAction[NavigationAction[\"Esc\"] = 7] = \"Esc\";\n    NavigationAction[NavigationAction[\"Navigate\"] = 8] = \"Navigate\";\n  })(NavigationAction || (NavigationAction = {}));\n  return NavigationAction;\n})();\n/**\n * @hidden\n */\nconst NAVIGATION_CONFIG = new InjectionToken('navigation.config');\n\n/**\n * @hidden\n */\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(config) {\n      this.navigate = new EventEmitter();\n      this.open = new EventEmitter();\n      this.close = new EventEmitter();\n      this.enter = new EventEmitter();\n      this.enterpress = new EventEmitter();\n      this.enterup = new EventEmitter();\n      this.tab = new EventEmitter();\n      this.esc = new EventEmitter();\n      this.useLeftRightArrows = config.useLeftRightArrows;\n    }\n    process(args) {\n      const keyCode = args.keyCode;\n      const keyEvent = args.keyEvent;\n      let index;\n      let action = NavigationAction.Undefined;\n      if (keyEvent === KeyEvents.keyup) {\n        if (this.isEnterOrSpace(keyCode)) {\n          action = NavigationAction.EnterUp;\n        }\n      } else {\n        if (args.altKey && keyCode === Keys.ArrowDown) {\n          action = NavigationAction.Open;\n        } else if (args.altKey && keyCode === Keys.ArrowUp) {\n          action = NavigationAction.Close;\n        } else if (this.isEnterOrSpace(keyCode)) {\n          action = NavigationAction.Enter;\n        } else if (keyCode === Keys.Escape) {\n          action = NavigationAction.Esc;\n        } else if (keyCode === Keys.Tab) {\n          action = NavigationAction.Tab;\n        } else if (keyCode === Keys.ArrowUp || this.useLeftRightArrows && keyCode === Keys.ArrowLeft) {\n          const step = args.flipNavigation ? 1 : -1;\n          const start = args.flipNavigation ? args.min : args.max;\n          const end = args.flipNavigation ? args.max : args.min;\n          index = this.next({\n            current: args.current,\n            start: start,\n            end: end,\n            step: step\n          });\n          action = NavigationAction.Navigate;\n        } else if (keyCode === Keys.ArrowDown || this.useLeftRightArrows && keyCode === Keys.ArrowRight) {\n          const step = args.flipNavigation ? -1 : 1;\n          const start = args.flipNavigation ? args.max : args.min;\n          const end = args.flipNavigation ? args.min : args.max;\n          index = this.next({\n            current: args.current,\n            start: start,\n            end: end,\n            step: step\n          });\n          action = NavigationAction.Navigate;\n        } else if (keyCode === Keys.Home) {\n          index = args.min;\n          action = NavigationAction.Navigate;\n        } else if (keyCode === Keys.End) {\n          index = args.max;\n          action = NavigationAction.Navigate;\n        }\n      }\n      if (action !== NavigationAction.Undefined) {\n        this[NavigationAction[action].toLowerCase()].emit({\n          index,\n          target: args.target\n        });\n      }\n      return action;\n    }\n    isEnterOrSpace(keyCode) {\n      return keyCode === Keys.Enter || keyCode === Keys.Space;\n    }\n    next(args) {\n      if (!isPresent(args.current)) {\n        return args.start;\n      } else {\n        return args.current !== args.end ? args.current + args.step : args.end;\n      }\n    }\n  }\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(NAVIGATION_CONFIG));\n  };\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet PopupContainerService = /*#__PURE__*/(() => {\n  class PopupContainerService {}\n  PopupContainerService.ɵfac = function PopupContainerService_Factory(t) {\n    return new (t || PopupContainerService)();\n  };\n  PopupContainerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PopupContainerService,\n    factory: PopupContainerService.ɵfac\n  });\n  return PopupContainerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ListButton = /*#__PURE__*/(() => {\n  class ListButton {\n    constructor(focusService, navigationService, wrapperRef, _zone, popupService, elRef, localization, cdr, containerService) {\n      this.focusService = focusService;\n      this.navigationService = navigationService;\n      this.wrapperRef = wrapperRef;\n      this._zone = _zone;\n      this.popupService = popupService;\n      this.elRef = elRef;\n      this.cdr = cdr;\n      this.containerService = containerService;\n      this._open = false;\n      this._disabled = false;\n      this._active = false;\n      this._popupSettings = {\n        animate: true,\n        popupClass: ''\n      };\n      this.listId = guid();\n      this._isFocused = false;\n      this.subs = new Subscription();\n      this.popupSubs = new Subscription();\n      /**\n       * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      this.tabIndex = 0;\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n      this.close = new EventEmitter();\n      this.isClosePrevented = false;\n      validatePackage(packageMetadata);\n      this.focusService = focusService;\n      this.navigationService = navigationService;\n      this.wrapper = wrapperRef.nativeElement;\n      this.subs.add(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.subscribeEvents();\n    }\n    /**\n     * Sets the disabled state of the DropDownButton.\n     */\n    set disabled(value) {\n      if (value && this.openState) {\n        this.openState = false;\n      }\n      this._disabled = value;\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n      return this.disabled ? -1 : this.tabIndex;\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.containerService.container : appendTo;\n    }\n    /**\n     * Configures the popup of the DropDownButton.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     * - `align: \"left\" | \"center\" | \"right\"`&mdash;Specifies the alignment of the popup.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true,\n        popupClass: ''\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * @hidden\n     */\n    get anchorAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'bottom'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    /**\n     * @hidden\n     */\n    get popupAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'top'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    ngOnChanges(changes) {\n      if (isChanged(\"popupSettings\", changes) && isPresent(this.popupRef)) {\n        const popup = this.popupRef.popup.instance;\n        const newSettings = changes['popupSettings'].currentValue;\n        popup.popupClass = newSettings.popupClass;\n        popup.animate = newSettings.animate;\n        popup.popupAlign = this.popupAlign;\n      }\n    }\n    get popupClasses() {\n      const popupClasses = ['k-menu-popup'];\n      if (this._popupSettings.popupClass) {\n        popupClasses.push(this._popupSettings.popupClass);\n      }\n      return popupClasses.join(' ');\n    }\n    get openState() {\n      return this._open;\n    }\n    /**\n     * @hidden\n     */\n    set openState(open) {\n      if (this.disabled) {\n        return;\n      }\n      this._open = open;\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n      return this._open;\n    }\n    /**\n     * @hidden\n     */\n    togglePopupVisibility() {\n      if (this._disabled) {\n        return;\n      }\n      this._toggle(!this.openState, true);\n      if (!this.isClosePrevented) {\n        this.focusService.focus(this.openState ? 0 : -1);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onItemClick(index) {\n      this.togglePopupVisibility();\n      if (this.isClosePrevented) {\n        this.emitItemClickHandler(index);\n        return;\n      }\n      if (isDocumentAvailable() && !this.isClosePrevented) {\n        this.focusButton();\n      }\n      this.emitItemClickHandler(index);\n    }\n    ngOnDestroy() {\n      this.openState = false;\n      this.subs.unsubscribe();\n      this.destroyPopup();\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subscribeListItemFocusEvent();\n      this.subscribeComponentBlurredEvent();\n      this.subscribeNavigationEvents();\n    }\n    subscribeListItemFocusEvent() {\n      this.subs.add(this.focusService.onFocus.subscribe(() => {\n        this._isFocused = true;\n      }));\n    }\n    subscribeComponentBlurredEvent() {\n      this._zone.runOutsideAngular(() => {\n        this.subs.add(this.navigationService.tab.pipe(filter(() => this._isFocused), tap(() => this.focusButton())).subscribe(this.handleTab.bind(this)));\n        this.subs.add(fromEvent(document, 'click').pipe(filter(event => !this.wrapperContains(event.target)), filter(() => this._isFocused)).subscribe(() => this._zone.run(() => this.blurWrapper())));\n      });\n    }\n    subscribeNavigationEvents() {\n      this.subs.add(this.navigationService.navigate.subscribe(this.onArrowKeyNavigate.bind(this)));\n      this.subs.add(this.navigationService.enterup.subscribe(this.onNavigationEnterUp.bind(this)));\n      this.subs.add(this.navigationService.open.subscribe(this.onNavigationOpen.bind(this)));\n      this.subs.add(merge(this.navigationService.close, this.navigationService.esc).subscribe(this.onNavigationClose.bind(this)));\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If the `toggle` method is used to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      if (this.disabled) {\n        return;\n      }\n      const value = open === undefined ? !this.openState : open;\n      this._toggle(value, false);\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(event, isHost) {\n      this.keyHandler(event, null, isHost);\n    }\n    /**\n     * @hidden\n     */\n    keyUpHandler(event) {\n      this.keyHandler(event, KeyEvents.keyup);\n    }\n    /**\n     * @hidden\n     */\n    keyHandler(event, keyEvent, isHost) {\n      if (this._disabled) {\n        return;\n      }\n      const eventData = event;\n      if (!isHost) {\n        eventData.stopImmediatePropagation();\n      }\n      const focused = this.focusService.focused || 0;\n      const action = this.navigationService.process({\n        altKey: eventData.altKey,\n        current: focused,\n        keyCode: eventData.keyCode,\n        keyEvent: keyEvent,\n        max: this._data ? this._data.length - 1 : 0,\n        min: 0,\n        target: event.target\n      });\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab && (action !== NavigationAction.Enter || action === NavigationAction.Enter && this.openState)) {\n        if (!(event.keyCode === Keys.Space && action === NavigationAction.EnterUp)) {\n          eventData.preventDefault();\n        }\n      }\n    }\n    emitItemClickHandler(index) {\n      const dataItem = this._data[index];\n      if (this._itemClick) {\n        this._itemClick.emit(dataItem);\n      }\n      if (dataItem && dataItem.click && !dataItem.disabled) {\n        dataItem.click(dataItem);\n      }\n      this.focusService.focus(index);\n    }\n    focusWrapper() {\n      if (this.openState) {\n        this.togglePopupVisibility();\n        this.focusButton();\n      }\n    }\n    wrapperContains(element) {\n      return this.wrapper === element || this.wrapper.contains(element);\n    }\n    blurWrapper(emit = true) {\n      if (!this._isFocused) {\n        return;\n      }\n      if (this.openState) {\n        this.togglePopupVisibility();\n      }\n      this._isFocused = false;\n      if (emit) {\n        this._blur.emit();\n        this.cdr.markForCheck();\n      }\n    }\n    focusButton() {\n      if (this.button) {\n        this.button.nativeElement.focus();\n      }\n    }\n    handleTab() {\n      this.blurWrapper();\n    }\n    onNavigationEnterUp() {\n      if (!this._disabled && !this.openState) {\n        this._active = false;\n      }\n      if (this.openState) {\n        const focused = this.focusService.focused;\n        if (isPresent(focused) && focused !== -1) {\n          this.emitItemClickHandler(focused);\n        }\n      }\n      this.togglePopupVisibility();\n      if (!this.openState && isDocumentAvailable()) {\n        this.button.nativeElement.focus();\n      }\n    }\n    onNavigationOpen() {\n      if (!this._disabled && !this.openState) {\n        this.togglePopupVisibility();\n      }\n    }\n    onNavigationClose() {\n      if (this.openState && !this.isClosePrevented) {\n        this.togglePopupVisibility();\n        if (isDocumentAvailable()) {\n          this.button.nativeElement.focus();\n        }\n      }\n    }\n    onArrowKeyNavigate({\n      index\n    }) {\n      this.focusService.focus(index);\n    }\n    _toggle(open, emitEvent) {\n      if (this.openState === open) {\n        return;\n      }\n      const eventArgs = new PreventableEvent();\n      if (emitEvent) {\n        if (open && !this.openState) {\n          this.open.emit(eventArgs);\n        } else if (!open && this.openState) {\n          this.close.emit(eventArgs);\n        }\n        if (eventArgs.isDefaultPrevented()) {\n          this.isClosePrevented = true;\n          return;\n        }\n      }\n      this.openState = open;\n      this.destroyPopup();\n      if (this.openState) {\n        this.createPopup();\n      }\n    }\n    createPopup() {\n      this.popupRef = this.popupService.open({\n        anchor: this.elRef,\n        anchorAlign: this.anchorAlign,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.containerService.template,\n        popupAlign: this.popupAlign,\n        popupClass: this.popupClasses\n      });\n      this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n        this.togglePopupVisibility();\n      });\n    }\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.popupSubs.unsubscribe();\n        this.isClosePrevented = false;\n      }\n    }\n  }\n  ListButton.ɵfac = function ListButton_Factory(t) {\n    return new (t || ListButton)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3$1.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PopupContainerService));\n  };\n  ListButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ListButton,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      disabled: \"disabled\",\n      tabIndex: \"tabIndex\",\n      buttonClass: \"buttonClass\",\n      popupSettings: \"popupSettings\"\n    },\n    outputs: {\n      open: \"open\",\n      close: \"close\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function ListButton_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ListButton;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet Messages = /*#__PURE__*/(() => {\n  class Messages extends ComponentMessages {}\n  Messages.ɵfac = /* @__PURE__ */function () {\n    let ɵMessages_BaseFactory;\n    return function Messages_Factory(t) {\n      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = i0.ɵɵgetInheritedFactory(Messages)))(t || Messages);\n    };\n  }();\n  Messages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Messages,\n    selectors: [[\"kendo-splitbutton-messages-base\"]],\n    inputs: {\n      splitButtonLabel: \"splitButtonLabel\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Messages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedSplitButtonMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedSplitButtonMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n  }\n  LocalizedSplitButtonMessagesDirective.ɵfac = function LocalizedSplitButtonMessagesDirective_Factory(t) {\n    return new (t || LocalizedSplitButtonMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n  LocalizedSplitButtonMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedSplitButtonMessagesDirective,\n    selectors: [[\"\", \"kendoSplitButtonLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => LocalizedSplitButtonMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedSplitButtonMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAVIGATION_SETTINGS$2 = {\n  useLeftRightArrows: true\n};\nconst NAVIGATION_SETTINGS_PROVIDER$2 = {\n  provide: NAVIGATION_CONFIG,\n  useValue: NAVIGATION_SETTINGS$2\n};\nconst DEFAULT_ROUNDED$2 = 'medium';\nconst DEFAULT_FILL_MODE$2 = 'solid';\n/**\n * Represents the Kendo UI SplitButton component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-splitbutton [data]=\"data\" icon=\"clipboard\"\n *      (itemClick)=\"onSplitButtonItemClick($event)\"\n *      (buttonClick)=\"onSplitButtonClick()\">Paste</kendo-splitbutton>\n * `\n * })\n *\n * class AppComponent {\n *   public data: Array<any> = [{\n *       text: 'Keep Text Only',\n *       icon: 'clipboard-text',\n *       click: () => { console.log('Keep Text Only click handler'); }\n *   }, {\n *       text: 'Paste as HTML',\n *       icon: 'clipboard-code'\n *   }, {\n *       text: 'Paste Markdown',\n *       icon: 'clipboard-markdown'\n *   }, {\n *       text: 'Set Default Paste'\n *   }];\n *\n *   public onSplitButtonClick(dataItem: any): void {\n *       console.log('Paste');\n *   }\n *\n *   public onSplitButtonItemClick(dataItem: any): void {\n *       if (dataItem) {\n *           console.log(dataItem.text);\n *       }\n *   }\n * }\n * ```\n */\nlet SplitButtonComponent = /*#__PURE__*/(() => {\n  class SplitButtonComponent extends ListButton {\n    constructor(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, renderer, containerService) {\n      super(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, containerService);\n      this.localization = localization;\n      this.renderer = renderer;\n      /**\n       * Sets the text of the SplitButton.\n       */\n      this.text = '';\n      /**\n       * Defines an icon to be rendered next to the button text.\n       * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n       */\n      this.icon = '';\n      /**\n       * Defines the type attribute of the main button\n       */\n      this.type = 'button';\n      /**\n       * Defines the location of an image to be displayed next to the button text\n       * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n       */\n      this.imageUrl = '';\n      /**\n       * The size property specifies the padding of the SplitButton\n       * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-size)).\n       *\n       * The possible values are:\n       * * `small`\n       * * `medium` (default)\n       * * `large`\n       * * `none`\n       */\n      this.size = 'medium';\n      /**\n       * The SplitButton allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly\n       * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-themeColor)).\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `none`&mdash; Removes the built in theme color.\n       */\n      this.themeColor = 'base';\n      /**\n       * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      this.tabIndex = 0;\n      /**\n       * Specifies the name of the [font icon]({% slug icons %}#toc-list-of-font-icons) that will\n       * be rendered for the button which opens the popup.\n       */\n      this.arrowButtonIcon = 'caret-alt-down';\n      /**\n       * Specifies the [`SVGIcon`](slug:api_icons_svgicon) that will\n       * be rendered for the button which opens the popup.\n       */\n      this.arrowButtonSvgIcon = caretAltDownIcon;\n      /**\n       * Fires each time the user clicks the main button.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       *    selector: 'my-app',\n       *    template: `\n       *        <kendo-splitbutton (buttonClick)=\"onSplitButtonClick()\" [data]=\"data\">\n       *            Reply\n       *        </kendo-splitbutton>\n       *    `\n       * })\n       * class AppComponent {\n       *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];\n       *\n       *    public onSplitButtonClick(): void {\n       *      console.log('SplitButton click');\n       *    }\n       * }\n       * ```\n       *\n       */\n      this.buttonClick = new EventEmitter();\n      /**\n       * Fires each time the user clicks on the drop-down list. The event data contains the data item bound to the clicked list item.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       *     selector: 'my-app',\n       *    template: `\n       *        <kendo-splitbutton (itemClick)=\"onSplitButtonItemClick($event)\" [data]=\"data\">\n       *          Reply\n       *      </kendo-splitbutton>\n       *    `\n       * })\n       * class AppComponent {\n       *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];\n       *\n       *   public onSplitButtonItemClick(dataItem?: string): void {\n       *        if (dataItem) {\n       *            console.log(dataItem);\n       *       }\n       *    }\n       * }\n       * ```\n       *\n       */\n      this.itemClick = new EventEmitter();\n      /**\n       * Fires each time the SplitButton gets focused.\n       */\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the SplitButton gets blurred.\n       */\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n      this.close = new EventEmitter();\n      /**\n       * @hidden\n       */\n      this.activeArrow = false;\n      this.listId = guid();\n      this.buttonText = '';\n      this.arrowButtonClicked = false;\n      this._rounded = DEFAULT_ROUNDED$2;\n      this._fillMode = DEFAULT_FILL_MODE$2;\n      this._itemClick = this.itemClick;\n      this._blur = this.onBlur;\n    }\n    /**\n     * The rounded property specifies the border radius of the SplitButton\n     * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-rounded)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$2;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the SplitButton\n     * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-fillMode)).\n     *\n     * The available values are:\n     * * `solid` (default)\n     * * `flat`\n     * * `outline`\n     * * `link`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$2;\n      this._fillMode = fillMode === 'clear' ? 'flat' : newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * When set to `true`, disables a SplitButton item\n     * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n     */\n    set disabled(value) {\n      if (this.isOpen) {\n        this.toggle(false);\n      }\n      this._disabled = value;\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Configures the popup of the SplitButton.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     * - `align: \"left\" | \"center\" | \"right\"`&mdash;Specifies the alignment of the popup.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true,\n        popupClass: ''\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Sets the data of the SplitButton.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this._data = data || [];\n    }\n    get data() {\n      if (!this._data) {\n        this.data = [];\n      }\n      return this._data;\n    }\n    /**\n     * @hidden\n     */\n    get hasContent() {\n      return this.button?.nativeElement.childElementCount > 0;\n    }\n    /**\n     * @hidden\n     */\n    get active() {\n      return this._active;\n    }\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n      return this.disabled ? -1 : this.tabIndex;\n    }\n    set isFocused(value) {\n      this._isFocused = value;\n    }\n    get isFocused() {\n      return this._isFocused && !this._disabled && isDocumentAvailable() && this.wrapperContains(document.activeElement);\n    }\n    get widgetClasses() {\n      return true;\n    }\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    get ariaLabel() {\n      const localizationMsg = this.localization.get('splitButtonLabel') || '';\n      return replaceMessagePlaceholder(localizationMsg, 'buttonText', this.buttonText);\n    }\n    /**\n     * @hidden\n     */\n    onButtonFocus(event) {\n      if (!this._disabled) {\n        // eslint-disable-next-line no-unused-expressions\n        !this._isFocused && this.onFocus.emit();\n        this._isFocused = true;\n        this.focusService.resetFocus();\n        const relatedTargetInList = event.relatedTarget && closest(event.relatedTarget, '.k-popup kendo-button-list');\n        if (this.openState && !relatedTargetInList) {\n          this.focusService.focus(0);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onArrowButtonClick() {\n      this.togglePopupVisibility();\n      this.arrowButtonClicked = false;\n    }\n    /**\n     * @hidden\n     */\n    toggleButtonActiveState(enable) {\n      this._active = enable;\n    }\n    /**\n     * @hidden\n     */\n    toggleArrowButtonActiveState(enable) {\n      this.arrowButtonClicked = true;\n      this.activeArrow = enable;\n    }\n    /**\n     * @hidden\n     */\n    onButtonClick() {\n      this.buttonClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    onButtonBlur() {\n      if (!this.isOpen && !this.arrowButtonClicked) {\n        this.blurWrapper();\n      }\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n      this.keyDownHandler(event, true);\n      if (event.keyCode === Keys.Space) {\n        this._active = true;\n      }\n    }\n    /**\n     * @hidden\n     */\n    keyup(event) {\n      this._active = false;\n      if (event.keyCode !== Keys.Space) {\n        this.keyUpHandler(event);\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n      this.containerService.container = this.containerRef;\n      this.containerService.template = this.popupTemplate;\n      this.updateButtonText();\n      this.handleClasses(this.rounded, 'rounded');\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (changes.hasOwnProperty('text')) {\n        this.updateButtonText();\n      }\n      if (anyChanged(['text', 'icon', 'svgIcon', 'iconClass', 'imageUrl'], changes)) {\n        this.toggleButtonIconClass();\n      }\n      if (isChanged('popupSettings', changes) && isPresent(this.popupRef)) {\n        const popup = this.popupRef.popup.instance;\n        const newSettings = changes['popupSettings'].currentValue;\n        popup.popupClass = newSettings.popupClass;\n        popup.animate = newSettings.animate;\n        popup.popupAlign = this.popupAlign;\n      }\n    }\n    /**\n     * @hidden\n     */\n    onNavigationEnterUp(args) {\n      if (args.target !== this.button.nativeElement) {\n        super.onNavigationEnterUp();\n      }\n    }\n    /**\n     * @hidden\n     */\n    togglePopupVisibility() {\n      if (isDocumentAvailable() && this.wrapperContains(document.activeElement) && this.arrowButtonClicked) {\n        this.button.nativeElement.focus();\n      }\n      super.togglePopupVisibility();\n    }\n    /**\n     * @hidden\n     */\n    wrapperContains(element) {\n      return this.wrapper === element || this.wrapper.contains(element) || this.popupRef && this.popupRef.popupElement.contains(element);\n    }\n    /**\n     * @hidden\n     */\n    get anchorAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'bottom'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    /**\n     * @hidden\n     */\n    get popupAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'top'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    /**\n     * @hidden\n     */\n    get isIconButton() {\n      const hasIcon = this.icon || this.svgIcon || this.iconClass || this.imageUrl;\n      const hasTextContent = isDocumentAvailable() && this.button?.nativeElement.textContent.trim().length > 0;\n      return hasIcon && !hasTextContent;\n    }\n    /**\n     * Focuses the SplitButton component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the SplitButton component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.blur();\n        this.blurWrapper();\n      }\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n      return this.openState;\n    }\n    updateButtonText() {\n      if (isDocumentAvailable()) {\n        const innerText = this.wrapper.innerText.split('\\n').join('').trim();\n        //setTimeout is needed because of `Expression has changed after it was checked.` error;\n        setTimeout(() => this.buttonText = innerText, 0);\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.wrapperRef.nativeElement;\n      const classes = getStylingClasses('button', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    toggleButtonIconClass() {\n      this.button.nativeElement.classList[this.isIconButton ? 'add' : 'remove']('k-button-icon');\n    }\n  }\n  SplitButtonComponent.ɵfac = function SplitButtonComponent_Factory(t) {\n    return new (t || SplitButtonComponent)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3$1.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PopupContainerService));\n  };\n  SplitButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SplitButtonComponent,\n    selectors: [[\"kendo-splitbutton\"]],\n    contentQueries: function SplitButtonComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ButtonItemTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n      }\n    },\n    viewQuery: function SplitButtonComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 5, ElementRef);\n        i0.ɵɵviewQuery(_c6, 5, ElementRef);\n        i0.ɵɵviewQuery(_c7, 5);\n        i0.ɵɵviewQuery(_c8, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.button = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.arrowButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.containerRef = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function SplitButtonComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function SplitButtonComponent_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        })(\"keyup\", function SplitButtonComponent_keyup_HostBindingHandler($event) {\n          return ctx.keyup($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-focus\", ctx.isFocused)(\"k-split-button\", ctx.widgetClasses)(\"k-button-group\", ctx.widgetClasses);\n      }\n    },\n    inputs: {\n      text: \"text\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      type: \"type\",\n      imageUrl: \"imageUrl\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      disabled: \"disabled\",\n      popupSettings: \"popupSettings\",\n      tabIndex: \"tabIndex\",\n      textField: \"textField\",\n      data: \"data\",\n      buttonClass: \"buttonClass\",\n      arrowButtonClass: \"arrowButtonClass\",\n      arrowButtonIcon: \"arrowButtonIcon\",\n      arrowButtonSvgIcon: \"arrowButtonSvgIcon\"\n    },\n    outputs: {\n      buttonClick: \"buttonClick\",\n      itemClick: \"itemClick\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoSplitButton\"],\n    features: [i0.ɵɵProvidersFeature([FocusService, NavigationService, NAVIGATION_SETTINGS_PROVIDER$2, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.splitbutton'\n    }, PopupContainerService]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 12,\n    vars: 32,\n    consts: function () {\n      let i18n_9;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text for the SplitButton aria-label\n         * @meaning kendo.splitbutton.splitButtonLabel\n         */\n        const MSG_D__WORK_TESTTASK_TESTTASK_CLIENTAPP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_BUTTONS_FESM2020_PROGRESS_KENDO_ANGULAR_BUTTONS_MJS_10 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ '{buttonText} splitbutton' }}\"\n          }\n        });\n        i18n_9 = MSG_D__WORK_TESTTASK_TESTTASK_CLIENTAPP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_BUTTONS_FESM2020_PROGRESS_KENDO_ANGULAR_BUTTONS_MJS_10;\n      } else {\n        i18n_9 = $localize`:kendo.splitbutton.splitButtonLabel|The text for the SplitButton aria-label:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      return [[\"kendoSplitButtonLocalizedMessages\", \"\", 6, \"splitButtonLabel\"], [\"splitButtonLabel\", i18n_9], [\"kendoButton\", \"\", 3, \"type\", \"tabindex\", \"disabled\", \"size\", \"rounded\", \"fillMode\", \"themeColor\", \"icon\", \"svgIcon\", \"iconClass\", \"imageUrl\", \"ngClass\", \"focus\", \"click\", \"blur\", \"mousedown\", \"mouseup\"], [\"button\", \"\"], [\"class\", \"k-button-text\", 4, \"ngIf\"], [\"kendoButton\", \"\", \"type\", \"button\", \"aria-hidden\", \"true\", 1, \"k-split-button-arrow\", 3, \"ngClass\", \"disabled\", \"icon\", \"svgIcon\", \"size\", \"rounded\", \"fillMode\", \"themeColor\", \"tabindex\", \"click\", \"mousedown\", \"mouseup\"], [\"arrowButton\", \"\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [1, \"k-button-text\"], [3, \"id\", \"data\", \"textField\", \"itemTemplate\", \"size\", \"onItemClick\", \"keydown\", \"keyup\"]];\n    },\n    template: function SplitButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵi18nAttributes(1, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(2, \"button\", 2, 3);\n        i0.ɵɵlistener(\"focus\", function SplitButtonComponent_Template_button_focus_2_listener($event) {\n          return ctx.onButtonFocus($event);\n        })(\"click\", function SplitButtonComponent_Template_button_click_2_listener() {\n          return ctx.onButtonClick();\n        })(\"blur\", function SplitButtonComponent_Template_button_blur_2_listener() {\n          return ctx.onButtonBlur();\n        })(\"mousedown\", function SplitButtonComponent_Template_button_mousedown_2_listener() {\n          return ctx.toggleButtonActiveState(true);\n        })(\"mouseup\", function SplitButtonComponent_Template_button_mouseup_2_listener() {\n          return ctx.toggleButtonActiveState(false);\n        });\n        i0.ɵɵtemplate(4, SplitButtonComponent_span_4_Template, 2, 1, \"span\", 4);\n        i0.ɵɵprojection(5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"button\", 5, 6);\n        i0.ɵɵlistener(\"click\", function SplitButtonComponent_Template_button_click_6_listener() {\n          return ctx.onArrowButtonClick();\n        })(\"mousedown\", function SplitButtonComponent_Template_button_mousedown_6_listener() {\n          return ctx.toggleArrowButtonActiveState(true);\n        })(\"mouseup\", function SplitButtonComponent_Template_button_mouseup_6_listener() {\n          return ctx.toggleArrowButtonActiveState(false);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, SplitButtonComponent_ng_template_8_Template, 1, 6, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(10, null, 8);\n      }\n      if (rf & 2) {\n        i0.ɵɵi18nExp(\"{buttonText} splitbutton\");\n        i0.ɵɵi18nApply(1);\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassProp(\"k-active\", ctx.active);\n        i0.ɵɵproperty(\"type\", ctx.type)(\"tabindex\", ctx.componentTabIndex)(\"disabled\", ctx.disabled)(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"themeColor\", ctx.themeColor)(\"icon\", ctx.icon)(\"svgIcon\", ctx.svgIcon)(\"iconClass\", ctx.iconClass)(\"imageUrl\", ctx.imageUrl)(\"ngClass\", ctx.buttonClass);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabled)(\"aria-expanded\", ctx.openState)(\"aria-haspopup\", true)(\"aria-owns\", ctx.listId)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.text);\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassProp(\"k-active\", ctx.activeArrow);\n        i0.ɵɵproperty(\"ngClass\", ctx.arrowButtonClass)(\"disabled\", ctx.disabled)(\"icon\", ctx.arrowButtonIcon)(\"svgIcon\", ctx.arrowButtonSvgIcon)(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"themeColor\", ctx.themeColor)(\"tabindex\", -1);\n      }\n    },\n    dependencies: [ButtonComponent, ListComponent, LocalizedSplitButtonMessagesDirective, i3.NgClass, i3.NgIf],\n    encapsulation: 2\n  });\n  return SplitButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_buttons %}).\n */\nlet SplitButtonCustomMessagesComponent = /*#__PURE__*/(() => {\n  class SplitButtonCustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  SplitButtonCustomMessagesComponent.ɵfac = function SplitButtonCustomMessagesComponent_Factory(t) {\n    return new (t || SplitButtonCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n  SplitButtonCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SplitButtonCustomMessagesComponent,\n    selectors: [[\"kendo-splitbutton-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => SplitButtonCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function SplitButtonCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SplitButtonCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `SplitButtonComponent`&mdash;The SplitButtonComponent component class.\n */\nlet SplitButtonModule = /*#__PURE__*/(() => {\n  class SplitButtonModule {}\n  SplitButtonModule.ɵfac = function SplitButtonModule_Factory(t) {\n    return new (t || SplitButtonModule)();\n  };\n  SplitButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SplitButtonModule\n  });\n  SplitButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, PopupModule, ButtonModule, ListModule], ListModule]\n  });\n  return SplitButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAVIGATION_SETTINGS$1 = {\n  useLeftRightArrows: true\n};\nconst NAVIGATION_SETTINGS_PROVIDER$1 = {\n  provide: NAVIGATION_CONFIG,\n  useValue: NAVIGATION_SETTINGS$1\n};\nconst DEFAULT_FILL_MODE$1 = 'solid';\n/**\n * Represents the Kendo UI DropDownButton component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownbutton [data]=\"data\">\n *    User Settings\n *  </kendo-dropdownbutton>\n * `\n * })\n * class AppComponent {\n *   public data: Array<any> = [{\n *       text: 'My Profile'\n *   }, {\n *       text: 'Friend Requests'\n *   }, {\n *       text: 'Account Settings'\n *   }, {\n *       text: 'Support'\n *   }, {\n *       text: 'Log Out'\n *   }];\n * }\n * ```\n */\nlet DropDownButtonComponent = /*#__PURE__*/(() => {\n  class DropDownButtonComponent extends ListButton {\n    constructor(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, containerService) {\n      super(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, containerService);\n      this.containerService = containerService;\n      /**\n       * Defines the name of an existing icon in the Kendo UI theme.\n       */\n      this.icon = '';\n      /**\n       * Defines the list of CSS classes which are used for styling the Button with custom icons.\n       */\n      this.iconClass = '';\n      /**\n       * Defines a URL for styling the button with a custom image.\n       */\n      this.imageUrl = '';\n      /**\n       * The size property specifies the padding of the DropDownButton\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-size)).\n       *\n       * The possible values are:\n       * * `small`\n       * * `medium` (default)\n       * * `large`\n       * * `none`\n       */\n      this.size = 'medium';\n      /**\n       * The rounded property specifies the border radius of the DropDownButton\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-rounded)).\n       *\n       * The possible values are:\n       * * `small`\n       * * `medium` (default)\n       * * `large`\n       * * `full`\n       * * `none`\n       */\n      this.rounded = 'medium';\n      /**\n       * The DropDownButton allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `none` &mdash;Removes the default CSS class (no class would be rendered).\n       */\n      this.themeColor = 'base';\n      /**\n       * Fires each time the user clicks on a drop-down list item. The event data contains the data item bound to the clicked list item.\n       */\n      this.itemClick = new EventEmitter();\n      /**\n       * Fires each time the DropDownButton gets focused.\n       */\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the DropDownButton gets blurred.\n       */\n      this.onBlur = new EventEmitter();\n      this.listId = guid();\n      this.buttonId = guid();\n      this._fillMode = DEFAULT_FILL_MODE$1;\n      this._itemClick = this.itemClick;\n      this._blur = this.onBlur;\n    }\n    /**\n     * Sets or gets the data of the DropDownButton.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this._data = data || [];\n    }\n    get data() {\n      return this._data;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the DropDownButton\n     * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-fillMode)).\n     *\n     * The available values are:\n     * * `solid` (default)\n     * * `flat`\n     * * `outline`\n     * * `link`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      this._fillMode = fillMode === 'clear' ? 'flat' : fillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    get focused() {\n      return this._isFocused && !this._disabled;\n    }\n    get widgetClasses() {\n      return true;\n    }\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    get active() {\n      return this._active;\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n      this.keyDownHandler(event, true);\n      if (event.keyCode === Keys.Space || event.keyCode === Keys.Enter) {\n        this._active = true;\n      }\n      if (event.keyCode === Keys.Enter) {\n        event.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     */\n    keyup(event) {\n      this.keyUpHandler(event);\n      this._active = false;\n    }\n    /**\n     * @hidden\n     */\n    mousedown(event) {\n      if (this._disabled) {\n        event.preventDefault();\n      }\n      this._active = true;\n    }\n    /**\n     * @hidden\n     */\n    mouseup(event) {\n      if (this._disabled) {\n        event.preventDefault();\n      }\n      this._active = false;\n    }\n    /**\n     * @hidden\n     */\n    openPopup() {\n      this._isFocused = true;\n      this.togglePopupVisibility();\n    }\n    /**\n     * @hidden\n     */\n    onButtonBlur() {\n      if (!this.openState) {\n        this.blurWrapper();\n      }\n    }\n    /**\n     * Focuses the DropDownButton component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the DropDownButton component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.blur();\n        this.blurWrapper();\n      }\n    }\n    ngAfterViewInit() {\n      this.containerService.container = this.container;\n      this.containerService.template = this.popupTemplate;\n    }\n    /**\n     * @hidden\n     */\n    handleFocus(event) {\n      if (!this._disabled) {\n        // eslint-disable-next-line no-unused-expressions\n        !this._isFocused && this.onFocus.emit();\n        this._isFocused = true;\n        this.focusService.resetFocus();\n        const relatedTargetInList = event.relatedTarget && closest(event.relatedTarget, '.k-popup kendo-button-list');\n        if (this.openState && !relatedTargetInList) {\n          this.focusService.focus(0);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    wrapperContains(element) {\n      return this.wrapper === element || this.wrapper.contains(element) || this.popupRef && this.popupRef.popupElement.contains(element);\n    }\n  }\n  DropDownButtonComponent.ɵfac = function DropDownButtonComponent_Factory(t) {\n    return new (t || DropDownButtonComponent)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3$1.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PopupContainerService));\n  };\n  DropDownButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DropDownButtonComponent,\n    selectors: [[\"kendo-dropdownbutton\"]],\n    contentQueries: function DropDownButtonComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ButtonItemTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n      }\n    },\n    viewQuery: function DropDownButtonComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 5, ElementRef);\n        i0.ɵɵviewQuery(_c11, 5);\n        i0.ɵɵviewQuery(_c7, 5);\n        i0.ɵɵviewQuery(_c8, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.button = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttonList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function DropDownButtonComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function DropDownButtonComponent_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        })(\"keyup\", function DropDownButtonComponent_keyup_HostBindingHandler($event) {\n          return ctx.keyup($event);\n        })(\"mousedown\", function DropDownButtonComponent_mousedown_HostBindingHandler($event) {\n          return ctx.mousedown($event);\n        })(\"mouseup\", function DropDownButtonComponent_mouseup_HostBindingHandler($event) {\n          return ctx.mouseup($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-focus\", ctx.focused)(\"k-dropdown-button\", ctx.widgetClasses);\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\",\n      textField: \"textField\",\n      data: \"data\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\"\n    },\n    outputs: {\n      itemClick: \"itemClick\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoDropDownButton\"],\n    features: [i0.ɵɵProvidersFeature([FocusService, NavigationService, NAVIGATION_SETTINGS_PROVIDER$1, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dropdownbutton'\n    }, PopupContainerService]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 7,\n    vars: 18,\n    consts: [[\"kendoButton\", \"\", \"type\", \"button\", 3, \"id\", \"tabindex\", \"disabled\", \"icon\", \"svgIcon\", \"iconClass\", \"imageUrl\", \"ngClass\", \"size\", \"rounded\", \"fillMode\", \"themeColor\", \"click\", \"focus\", \"blur\"], [\"button\", \"\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"id\", \"data\", \"textField\", \"itemTemplate\", \"size\", \"onItemClick\", \"keydown\", \"keyup\"], [\"buttonList\", \"\"]],\n    template: function DropDownButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"click\", function DropDownButtonComponent_Template_button_click_0_listener() {\n          return ctx.openPopup();\n        })(\"focus\", function DropDownButtonComponent_Template_button_focus_0_listener($event) {\n          return ctx.handleFocus($event);\n        })(\"blur\", function DropDownButtonComponent_Template_button_blur_0_listener() {\n          return ctx.onButtonBlur();\n        });\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, DropDownButtonComponent_ng_template_3_Template, 2, 7, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(5, null, 3);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-active\", ctx.active);\n        i0.ɵɵproperty(\"id\", ctx.buttonId)(\"tabindex\", ctx.componentTabIndex)(\"disabled\", ctx.disabled)(\"icon\", ctx.icon)(\"svgIcon\", ctx.svgIcon)(\"iconClass\", ctx.iconClass)(\"imageUrl\", ctx.imageUrl)(\"ngClass\", ctx.buttonClass)(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"themeColor\", ctx.fillMode ? ctx.themeColor : null);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabled)(\"aria-expanded\", ctx.openState)(\"aria-haspopup\", true)(\"aria-controls\", ctx.listId);\n      }\n    },\n    dependencies: [ButtonComponent, ListComponent, i3.NgClass],\n    encapsulation: 2\n  });\n  return DropDownButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `DropDownButtonComponent`&mdash;The DropDownButtonComponent component class.\n */\nlet DropDownButtonModule = /*#__PURE__*/(() => {\n  class DropDownButtonModule {}\n  DropDownButtonModule.ɵfac = function DropDownButtonModule_Factory(t) {\n    return new (t || DropDownButtonModule)();\n  };\n  DropDownButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DropDownButtonModule\n  });\n  DropDownButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, PopupModule, ListModule, ButtonModule], ListModule]\n  });\n  return DropDownButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SIZE$1 = 'medium';\nconst DEFAULT_ROUNDED$1 = 'medium';\nconst DEFAULT_THEME_COLOR$1 = 'base';\nconst DEFAULT_FILL_MODE = 'solid';\n/**\n * Displays a Chip that represents an input, attribute or an action.\n */\nlet ChipComponent = /*#__PURE__*/(() => {\n  class ChipComponent {\n    constructor(element, renderer, ngZone, localizationService) {\n      this.element = element;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.localizationService = localizationService;\n      /**\n       * Specifies the selected state of the Chip.\n       * @default false\n       */\n      this.selected = false;\n      /**\n       * Specifies if the Chip will be removable or not.\n       * If the property is set to `true`, the Chip renders a remove icon.\n       * @default false\n       */\n      this.removable = false;\n      /**\n       * If set to `true`, the Chip will be disabled.\n       * @default false\n       */\n      this.disabled = false;\n      /**\n       * Fires each time the user clicks the remove icon of the Chip.\n       */\n      this.remove = new EventEmitter();\n      /**\n       * Fires each time the user clicks the content of the Chip.\n       */\n      this.contentClick = new EventEmitter();\n      this.tabIndex = 0;\n      this.hostClass = true;\n      /**\n       * @hidden\n       */\n      this.defaultRemoveIcon = xCircleIcon;\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      this._themeColor = 'base';\n      this.focused = false;\n      this.subs = new Subscription();\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * The size property specifies the padding of the Chip\n     * ([see example]({% slug appearance_chip %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$1;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the Chip\n     * ([see example]({% slug appearance_chip %}#toc-rounded)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the Chip\n     * ([see example]({% slug appearance_chip %}#toc-fillMode)).\n     *\n     * The possible values are:\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The Chip allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color while also amending the text color accordingly\n     * ([see example]({% slug appearance_chip %}#toc-themeColor)).\n     *\n     * The possible values are:\n     * * `base` (default)\n     * * `info`\n     * * `success`\n     * * `warning`\n     * * `error`\n     * * `none`\n     */\n    set themeColor(themeColor) {\n      const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR$1;\n      this.handleThemeColor(newThemeColor);\n      this._themeColor = newThemeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    get hasIconClass() {\n      return Boolean(this.icon || this.iconClass || this.avatarClass);\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    get selectedClass() {\n      return this.selected;\n    }\n    get focusedClass() {\n      return this.focused;\n    }\n    ngOnInit() {\n      this.subs.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.renderer.setAttribute(this.element.nativeElement, 'role', 'button');\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    ngOnChanges(changes) {\n      if (changes && changes['selected']) {\n        const hasAriaSelected = this.element.nativeElement.hasAttribute('aria-selected');\n        if (!hasAriaSelected) {\n          this.renderer.setAttribute(this.element.nativeElement, 'aria-pressed', `${this.selected}`);\n        }\n      }\n    }\n    ngAfterViewInit() {\n      const chip = this.element.nativeElement;\n      const stylingOptions = ['size', 'rounded', 'fillMode'];\n      stylingOptions.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.attachElementEventHandlers(chip);\n    }\n    /**\n     * @hidden\n     */\n    get kendoIconClass() {\n      this.verifyIconSettings([this.iconClass, this.avatarClass]);\n      return `k-i-${this.icon}`;\n    }\n    /**\n     * @hidden\n     */\n    get customIconClass() {\n      this.verifyIconSettings([this.icon, this.avatarClass]);\n      return this.iconClass;\n    }\n    /**\n     * @hidden\n     */\n    get chipAvatarClass() {\n      this.verifyIconSettings([this.icon, this.iconClass]);\n      return this.avatarClass;\n    }\n    /**\n     * @hidden\n     */\n    get removeIconClass() {\n      return this.removeIcon ? this.removeIcon : 'k-i-x-circle';\n    }\n    /**\n     * Focuses the Chip component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.element.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the Chip component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.element.nativeElement.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onRemoveClick(e) {\n      if (this.removable) {\n        this.remove.emit({\n          sender: this,\n          originalEvent: e\n        });\n      }\n    }\n    attachElementEventHandlers(chip) {\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(chip, 'focus', () => {\n          this.renderer.addClass(chip, 'k-focus');\n        }));\n        this.subs.add(this.renderer.listen(chip, 'blur', () => {\n          this.renderer.removeClass(chip, 'k-focus');\n        }));\n        this.subs.add(this.renderer.listen(chip, 'click', e => {\n          const isRemoveClicked = closest(e.target, '.k-chip-remove-action');\n          if (!isRemoveClicked) {\n            this.ngZone.run(() => {\n              this.contentClick.emit({\n                sender: this,\n                originalEvent: e\n              });\n            });\n          }\n        }));\n        this.subs.add(this.renderer.listen(chip, 'keydown', this.keyDownHandler.bind(this)));\n      });\n    }\n    /**\n     * @hidden\n     */\n    verifyIconSettings(iconsToCheck) {\n      if (isDevMode()) {\n        if (iconsToCheck.filter(icon => icon !== null && icon !== undefined).length > 0) {\n          this.renderer.removeClass(this.element.nativeElement, 'k-chip-has-icon');\n          throw new Error('Invalid configuration: Having multiple icons is not supported. Only a single icon on a chip can be displayed.');\n        }\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.element.nativeElement;\n      const classes = getStylingClasses('chip', input, this[input], value);\n      if (input === 'fillMode') {\n        this.handleThemeColor(this.themeColor, this[input], value);\n      }\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    handleThemeColor(value, prevFillMode, fillMode) {\n      const elem = this.element.nativeElement;\n      const removeFillMode = prevFillMode ? prevFillMode : this.fillMode;\n      const addFillMode = fillMode ? fillMode : this.fillMode;\n      const themeColorClass = getThemeColorClasses('chip', removeFillMode, addFillMode, this.themeColor, value);\n      this.renderer.removeClass(elem, themeColorClass.toRemove);\n      if (addFillMode !== 'none' && fillMode !== 'none') {\n        if (themeColorClass.toAdd) {\n          this.renderer.addClass(elem, themeColorClass.toAdd);\n        }\n      }\n    }\n    keyDownHandler(e) {\n      const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;\n      const isDeleteOrBackspace = e.keyCode === Keys.Delete || e.keyCode === Keys.Backspace;\n      if (this.disabled) {\n        return;\n      }\n      if (isEnterOrSpace) {\n        this.ngZone.run(() => {\n          this.contentClick.emit({\n            sender: this,\n            originalEvent: e\n          });\n        });\n      } else if (isDeleteOrBackspace && this.removable) {\n        this.ngZone.run(() => {\n          this.remove.emit({\n            sender: this,\n            originalEvent: e\n          });\n        });\n      }\n    }\n  }\n  ChipComponent.ɵfac = function ChipComponent_Factory(t) {\n    return new (t || ChipComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n  ChipComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ChipComponent,\n    selectors: [[\"kendo-chip\"]],\n    hostVars: 13,\n    hostBindings: function ChipComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndex)(\"aria-disabled\", ctx.disabledClass)(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-chip\", ctx.hostClass)(\"k-chip-has-icon\", ctx.hasIconClass)(\"k-disabled\", ctx.disabledClass)(\"k-selected\", ctx.selectedClass)(\"k-focus\", ctx.focusedClass);\n      }\n    },\n    inputs: {\n      label: \"label\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      avatarClass: \"avatarClass\",\n      selected: \"selected\",\n      removable: \"removable\",\n      removeIcon: \"removeIcon\",\n      removeSvgIcon: \"removeSvgIcon\",\n      disabled: \"disabled\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\"\n    },\n    outputs: {\n      remove: \"remove\",\n      contentClick: \"contentClick\"\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.chip'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 8,\n    vars: 6,\n    consts: [[\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"customFontClass\", 4, \"ngIf\"], [\"class\", \"k-chip-avatar k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full\", 4, \"ngIf\"], [1, \"k-chip-content\"], [\"class\", \"k-chip-label\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-chip-actions\"], [\"class\", \"k-chip-action k-chip-remove-action\", 3, \"click\", 4, \"ngIf\"], [\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"name\", \"svgIcon\"], [\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"customFontClass\"], [1, \"k-chip-avatar\", \"k-avatar\", \"k-avatar-md\", \"k-avatar-solid\", \"k-avatar-solid-primary\", \"k-rounded-full\"], [1, \"k-avatar-image\", 3, \"ngClass\"], [1, \"k-chip-label\"], [1, \"k-chip-action\", \"k-chip-remove-action\", 3, \"click\"], [\"name\", \"x-circle\", \"size\", \"small\", 3, \"svgIcon\", \"customFontClass\"]],\n    template: function ChipComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, ChipComponent_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, ChipComponent_kendo_icon_wrapper_1_Template, 1, 1, \"kendo-icon-wrapper\", 1);\n        i0.ɵɵtemplate(2, ChipComponent_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵtemplate(4, ChipComponent_span_4_Template, 2, 1, \"span\", 4);\n        i0.ɵɵtemplate(5, ChipComponent_ng_content_5_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"span\", 6);\n        i0.ɵɵtemplate(7, ChipComponent_span_7_Template, 2, 2, \"span\", 7);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.avatarClass);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.label);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.label);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.removable);\n      }\n    },\n    dependencies: [i2.IconWrapperComponent, i3.NgIf, i3.NgClass],\n    encapsulation: 2\n  });\n  return ChipComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ChipListComponent = /*#__PURE__*/(() => {\n  class ChipListComponent {\n    constructor(localizationService, renderer, element, ngZone) {\n      this.localizationService = localizationService;\n      this.renderer = renderer;\n      this.element = element;\n      this.ngZone = ngZone;\n      this.hostClass = true;\n      this.orientation = 'horizontal';\n      /**\n       * Sets the selection mode of the ChipList.\n       *\n       * The available values are:\n       * * `none` (default)\n       * * `single`\n       * * `multiple`\n       */\n      this.selection = 'none';\n      /**\n       * Fires each time when the ChipList selection is changed.\n       */\n      this.selectedChange = new EventEmitter();\n      /**\n       * Fires each time the user clicks on the remove icon of the Chip.\n       */\n      this.remove = new EventEmitter();\n      /**\n       * @hidden\n       */\n      this.role = 'listbox';\n      this._size = 'medium';\n      this.subs = new Subscription();\n      this._navigable = false;\n      this.currentActiveIndex = 0;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * The size property specifies the gap between the Chips in the ChipList\n     * ([see example]({% slug appearance_chiplist %}#toc-size)).\n     *\n     * The possible values are:\n     * * `'small'`\n     * * `'medium'` (default)\n     * * `'large'`\n     * * `none`\n     */\n    set size(size) {\n      const sizeValue = size ? size : 'medium';\n      this.handleClasses(sizeValue, 'size');\n      this._size = sizeValue;\n    }\n    get size() {\n      return this._size;\n    }\n    get single() {\n      return this.selection === 'single';\n    }\n    get multiple() {\n      return this.selection === 'multiple';\n    }\n    /**\n     * @hidden\n     */\n    onClick($event) {\n      const target = $event.target;\n      const isRemoveClicked = closest(target, '.k-chip-remove-action');\n      const clickedChip = closest(target, '.k-chip');\n      const chip = this.chips.find(chip => clickedChip === chip.element.nativeElement);\n      this.currentActiveIndex = this.chips.toArray().indexOf(chip);\n      chip && chip.focus();\n      if (isRemoveClicked && clickedChip) {\n        const removeEventArgs = {\n          sender: this,\n          originalEvent: $event,\n          removedChip: chip\n        };\n        this.remove.emit(removeEventArgs);\n      }\n      if (this.selection !== 'none' && clickedChip && !isRemoveClicked) {\n        this.setSelection(chip);\n      }\n    }\n    /**\n     * When set to `true`, keyboard navigation is available through arrow keys and roving tabindex. Otherwise, all chips\n     * are part of the default tabbing sequence of the page.\n     *\n     * @default false\n     */\n    set navigable(value) {\n      this._navigable = value;\n      this.chips?.forEach(c => this.renderer.setAttribute(c.element.nativeElement, 'tabindex', value ? '-1' : '0'));\n      this.chips?.first && this.renderer.setAttribute(this.chips.first.element.nativeElement, 'tabindex', '0');\n    }\n    get navigable() {\n      return this._navigable;\n    }\n    ngOnInit() {\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr');\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.attachElementEventHandlers();\n    }\n    ngAfterContentInit() {\n      this.updateChips();\n      this.subs.add(this.chips?.changes.subscribe(() => this.updateChips()));\n    }\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n      this.subs.unsubscribe();\n    }\n    selectedChips() {\n      return this.chips.reduce((acc, cur, idx) => {\n        return cur.selected ? acc.concat(idx) : acc;\n      }, []);\n    }\n    /**\n     * Updates the selection on click of a Chip. Emits events.\n     */\n    setSelection(chip) {\n      if (this.selection === 'single') {\n        this.clearSelection(chip);\n      }\n      chip.selected = !chip.selected;\n      const chipEl = chip.element.nativeElement;\n      this.renderer.setAttribute(chipEl, 'aria-selected', `${chip.selected}`);\n      this.selectedChange.emit(this.selectedChips());\n    }\n    clearSelection(chip) {\n      this.chips.forEach(c => {\n        if (chip !== c) {\n          c.selected = false;\n          this.renderer.setAttribute(c.element.nativeElement, 'aria-selected', 'false');\n        }\n      });\n    }\n    handleClasses(value, input) {\n      const elem = this.element.nativeElement;\n      const classes = getStylingClasses('chip-list', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    attachElementEventHandlers() {\n      const chiplist = this.element.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(chiplist, 'keydown', this.keyDownHandler.bind(this)));\n      });\n    }\n    keyDownHandler(e) {\n      const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;\n      const isDeleteOrBackspace = e.keyCode === Keys.Delete || e.keyCode === Keys.Backspace;\n      const isLeftArrow = e.keyCode === Keys.ArrowLeft;\n      const isRightArrow = e.keyCode === Keys.ArrowRight;\n      if (isEnterOrSpace) {\n        const target = e.target;\n        const clickedChip = closest(target, '.k-chip');\n        const chip = this.chips.find(chip => clickedChip === chip.element.nativeElement);\n        this.currentActiveIndex = this.chips.toArray().findIndex(chip => clickedChip === chip.element.nativeElement);\n        if (this.selection !== 'none' && clickedChip) {\n          this.ngZone.run(() => {\n            this.setSelection(chip);\n          });\n        }\n      } else if (isDeleteOrBackspace) {\n        const target = e.target;\n        const clickedChip = closest(target, '.k-chip');\n        const chip = this.chips.find(chip => clickedChip === chip.element.nativeElement);\n        if (clickedChip) {\n          const removeEventArgs = {\n            sender: this,\n            originalEvent: e,\n            removedChip: chip\n          };\n          this.ngZone.run(() => {\n            this.remove.emit(removeEventArgs);\n          });\n        }\n      } else if (isLeftArrow) {\n        this.handleArrowKeys('left');\n      } else if (isRightArrow) {\n        this.handleArrowKeys('right');\n      }\n    }\n    handleArrowKeys(direction) {\n      if (!this.navigable) {\n        return;\n      }\n      const directionDelta = direction === 'left' ? -1 : 1;\n      this.currentActiveIndex = this.currentActiveIndex + directionDelta;\n      if (this.currentActiveIndex >= this.chips.length) {\n        this.currentActiveIndex = 0;\n      } else if (this.currentActiveIndex < 0) {\n        this.currentActiveIndex = this.chips.length - 1;\n      }\n      this.chips.forEach((chip, idx) => {\n        this.renderer.removeAttribute(chip.element.nativeElement, 'tabindex');\n        if (idx === this.currentActiveIndex) {\n          this.renderer.setAttribute(chip.element.nativeElement, 'tabindex', '0');\n          chip.focus();\n        }\n      });\n    }\n    updateChips() {\n      this.normalizeActiveIndex();\n      this.chips.forEach((chip, idx) => {\n        const chipEl = chip.element.nativeElement;\n        this.renderer.removeAttribute(chip.element.nativeElement, 'tabindex');\n        if (idx === this.currentActiveIndex) {\n          this.renderer.setAttribute(chip.element.nativeElement, 'tabindex', '0');\n          if (isDocumentAvailable() && document.activeElement.closest('.k-chip-list')) {\n            chip.focus();\n          }\n        }\n        this.role === 'listbox' && this.renderer.setAttribute(chipEl, 'role', 'option');\n        if (chip.removable) {\n          this.renderer.setAttribute(chipEl, 'aria-keyshortcuts', 'Enter Delete');\n        }\n        this.renderer.removeAttribute(chipEl, 'aria-pressed');\n        this.renderer.setAttribute(chipEl, 'aria-selected', `${chip.selected}`);\n      });\n    }\n    normalizeActiveIndex() {\n      if (this.currentActiveIndex >= this.chips.length) {\n        this.currentActiveIndex = Math.max(this.chips.length - 1, 0);\n      }\n    }\n  }\n  ChipListComponent.ɵfac = function ChipListComponent_Factory(t) {\n    return new (t || ChipListComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  ChipListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ChipListComponent,\n    selectors: [[\"kendo-chiplist\"], [\"kendo-chip-list\"]],\n    contentQueries: function ChipListComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ChipComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chips = _t);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function ChipListComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function ChipListComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"dir\", ctx.direction)(\"aria-multiselectable\", ctx.multiple)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-chip-list\", ctx.hostClass)(\"k-selection-single\", ctx.single)(\"k-selection-multiple\", ctx.multiple);\n      }\n    },\n    inputs: {\n      selection: \"selection\",\n      size: \"size\",\n      role: \"role\",\n      navigable: \"navigable\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      remove: \"remove\"\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.chiplist'\n    }])],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function ChipListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ChipListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst exportedModules$1 = [ChipComponent, ChipListComponent];\nconst declarations$1 = [...exportedModules$1];\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Chip and ChipList components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Chip module\n * import { ChipModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ChipModule], // import Chip module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * ```\n */\nlet ChipModule = /*#__PURE__*/(() => {\n  class ChipModule {}\n  ChipModule.ɵfac = function ChipModule_Factory(t) {\n    return new (t || ChipModule)();\n  };\n  ChipModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ChipModule\n  });\n  ChipModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IconsModule]]\n  });\n  return ChipModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction getAnchorAlign(fabAlign, rtl) {\n  const align = {\n    horizontal: rtl ? 'right' : 'left',\n    vertical: 'bottom'\n  };\n  if (fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n  }\n  if (fabAlign.vertical === 'bottom') {\n    align.vertical = 'top';\n  }\n  if (fabAlign.vertical === 'bottom' && fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n    align.vertical = 'top';\n  }\n  return align;\n}\n/**\n * @hidden\n */\nfunction getPopupAlign(fabAlign, rtl) {\n  const align = {\n    horizontal: rtl ? 'right' : 'left',\n    vertical: 'top'\n  };\n  if (fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n  }\n  if (fabAlign.vertical === 'bottom') {\n    align.vertical = 'bottom';\n  }\n  if (fabAlign.vertical === 'bottom' && fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n    align.vertical = 'bottom';\n  }\n  return align;\n}\n\n/**\n * @hidden\n */\nfunction openAnimation(animationSettings) {\n  const isBottom = animationSettings.align.vertical === 'bottom';\n  const duration = animationSettings.duration;\n  const gap = animationSettings.gap;\n  return sequence([query(`.k-fab-item`, [style({\n    opacity: 0,\n    transform: `translateY(${isBottom ? '8px' : '-8px'})`\n  }), stagger(gap, [animate(`${duration}ms ease-in`, style({\n    opacity: '*',\n    transform: 'translateY(0)'\n  }))])], {\n    optional: true\n  })]);\n}\n/**\n * @hidden\n */\nfunction closeAnimation(animationSettings) {\n  const isBottom = animationSettings.align.vertical === 'bottom';\n  const duration = animationSettings.duration;\n  const gap = animationSettings.gap;\n  return sequence([query(`.k-fab-item`, [style({\n    opacity: '*',\n    transform: 'translateY(0)'\n  }), stagger(-gap, [animate(`${duration}ms ease-in`, style({\n    opacity: 0,\n    transform: `translateY(${isBottom ? '8px' : '-8px'})`\n  }))])], {\n    optional: true\n  })]);\n}\n\n/**\n * Represents a template that defines the content of the whole dial item.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDialItemTemplate` directive inside the `<kendo-floatingactionbutton>` tag\n * ([see example]({% slug templates_floatingactionbutton %}#toc-dial-item-template)).\n */\nlet DialItemTemplateDirective = /*#__PURE__*/(() => {\n  class DialItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n  }\n  DialItemTemplateDirective.ɵfac = function DialItemTemplateDirective_Factory(t) {\n    return new (t || DialItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n  DialItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DialItemTemplateDirective,\n    selectors: [[\"\", \"kendoDialItemTemplate\", \"\"]]\n  });\n  return DialItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the content of the FloatingActionButton.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoFloatingActionButtonTemplate` directive inside the `<kendo-floatingactionbutton>` tag\n * ([see example]({% slug templates_floatingactionbutton %}#toc-floatingactionbutton-template)).\n */\nlet FloatingActionButtonTemplateDirective = /*#__PURE__*/(() => {\n  class FloatingActionButtonTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n  }\n  FloatingActionButtonTemplateDirective.ɵfac = function FloatingActionButtonTemplateDirective_Factory(t) {\n    return new (t || FloatingActionButtonTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n  FloatingActionButtonTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FloatingActionButtonTemplateDirective,\n    selectors: [[\"\", \"kendoFloatingActionButtonTemplate\", \"\"]]\n  });\n  return FloatingActionButtonTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DialItemComponent = /*#__PURE__*/(() => {\n  class DialItemComponent {\n    constructor(element, renderer, localisationService) {\n      this.element = element;\n      this.renderer = renderer;\n      this.localisationService = localisationService;\n      this.hostClass = true;\n      this.role = 'menuitem';\n    }\n    get disabledClass() {\n      return this.item.disabled;\n    }\n    get title() {\n      const label = this.item.label;\n      return label || this.itemTitle;\n    }\n    get indexAttr() {\n      return this.index;\n    }\n    get iconClasses() {\n      const classes = [];\n      if (this.item.iconClass) {\n        classes.push(`${this.item.iconClass}`);\n      }\n      if (this.item.icon) {\n        classes.push(`k-fab-item-icon k-icon k-i-${this.item.icon}`);\n      }\n      return classes;\n    }\n    get itemTitle() {\n      const icon = this.item.icon;\n      const itemTitle = this.item.itemTitle;\n      return icon && itemTitle ? itemTitle : icon;\n    }\n    ngAfterViewInit() {\n      const element = this.element.nativeElement;\n      const rtl = this.localisationService.rtl;\n      const hAlign = this.align.horizontal;\n      this.renderer.addClass(element, this.getTextDirectionClass(rtl, hAlign));\n    }\n    getTextDirectionClass(rtl, hAlign) {\n      const dir = rtl ? 'rtl' : 'ltr';\n      const align = hAlign === 'end' ? 'end' : 'start';\n      const directions = {\n        rtl: {\n          end: 'k-text-left',\n          start: 'k-text-right'\n        },\n        ltr: {\n          start: 'k-text-left',\n          end: 'k-text-right'\n        }\n      };\n      return directions[dir][align];\n    }\n  }\n  DialItemComponent.ɵfac = function DialItemComponent_Factory(t) {\n    return new (t || DialItemComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n  DialItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DialItemComponent,\n    selectors: [[\"\", \"kendoDialItem\", \"\"]],\n    hostVars: 9,\n    hostBindings: function DialItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-disabled\", ctx.disabledClass)(\"title\", ctx.title)(\"aria-label\", ctx.title)(\"data-fab-item-index\", ctx.indexAttr);\n        i0.ɵɵclassProp(\"k-fab-item\", ctx.hostClass)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      cssClass: \"cssClass\",\n      cssStyle: \"cssStyle\",\n      isFocused: \"isFocused\",\n      index: \"index\",\n      item: \"item\",\n      dialItemTemplate: \"dialItemTemplate\",\n      align: \"align\"\n    },\n    attrs: _c12,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"k-fab-item-text\", 4, \"ngIf\"], [\"innerCssClass\", \"k-fab-item-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [1, \"k-fab-item-text\"], [\"innerCssClass\", \"k-fab-item-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"]],\n    template: function DialItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DialItemComponent_0_Template, 1, 6, null, 0);\n        i0.ɵɵtemplate(1, DialItemComponent_ng_container_1_Template, 3, 2, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.dialItemTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.dialItemTemplate);\n      }\n    },\n    dependencies: [i2.IconWrapperComponent, i3.NgIf, i3.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return DialItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DialListComponent = /*#__PURE__*/(() => {\n  class DialListComponent {\n    constructor(focusService, cdr) {\n      this.focusService = focusService;\n      this.cdr = cdr;\n      this.hostClass = true;\n      this.subscriptions = new Subscription();\n      this.subscriptions.add(this.focusService.onFocus.subscribe(() => this.cdr.detectChanges()));\n    }\n    get bottomClass() {\n      return this.align.vertical === 'top' || this.align.vertical === 'middle';\n    }\n    get topClass() {\n      return this.align.vertical === 'bottom';\n    }\n    isFocused(index) {\n      return this.focusService.isFocused(index);\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  DialListComponent.ɵfac = function DialListComponent_Factory(t) {\n    return new (t || DialListComponent)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  DialListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DialListComponent,\n    selectors: [[\"\", \"kendoDialList\", \"\"]],\n    hostVars: 6,\n    hostBindings: function DialListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-fab-items\", ctx.hostClass)(\"k-fab-items-bottom\", ctx.bottomClass)(\"k-fab-items-top\", ctx.topClass);\n      }\n    },\n    inputs: {\n      dialItems: \"dialItems\",\n      dialItemTemplate: \"dialItemTemplate\",\n      align: \"align\"\n    },\n    attrs: _c14,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"kendoButtonFocusable\", \"\", \"kendoDialItem\", \"\", 3, \"item\", \"index\", \"dialItemTemplate\", \"isFocused\", \"ngClass\", \"ngStyle\", \"align\"]],\n    template: function DialListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DialListComponent_ng_container_0_Template, 2, 7, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.dialItems);\n      }\n    },\n    dependencies: [DialItemComponent, i3.NgForOf, FocusableDirective, i3.NgClass, i3.NgStyle],\n    encapsulation: 2\n  });\n  return DialListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAVIGATION_SETTINGS = {\n  useLeftRightArrows: false\n};\nconst NAVIGATION_SETTINGS_PROVIDER = {\n  provide: NAVIGATION_CONFIG,\n  useValue: NAVIGATION_SETTINGS\n};\nconst SIZE_CLASSES = {\n  small: 'k-fab-sm',\n  medium: 'k-fab-md',\n  large: 'k-fab-lg'\n};\nconst ROUNDED_CLASSES = {\n  small: 'k-rounded-sm',\n  medium: 'k-rounded-md',\n  large: 'k-rounded-lg',\n  full: 'k-rounded-full'\n};\nconst FILLMODE_CLASS = 'k-fab-solid';\nconst DEFAULT_DURATION = 180;\nconst DEFAULT_ITEM_GAP = 90;\nconst DEFAULT_OFFSET = '16px';\nconst DEFAULT_ROUNDED = 'full';\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_THEME_COLOR = 'primary';\n/**\n *\n * Represents the [Kendo UI FloatingActionButton component for Angular]({% slug overview_floatingactionbutton %}).\n * Used to specify the primary or the most common action in an application.\n *\n */\nlet FloatingActionButtonComponent = /*#__PURE__*/(() => {\n  class FloatingActionButtonComponent {\n    constructor(renderer, element, focusService, navigationService, ngZone, popupService, builder, localizationService) {\n      this.renderer = renderer;\n      this.element = element;\n      this.focusService = focusService;\n      this.navigationService = navigationService;\n      this.ngZone = ngZone;\n      this.popupService = popupService;\n      this.builder = builder;\n      this.localizationService = localizationService;\n      /**\n       * Specifies the positionMode of the FloatingActionButton\n       * ([see example]({% slug positioning_floatingactionbutton %}#toc-positionMode)).\n       *\n       * * The possible values are:\n       * * `absolute`&mdash;Positions the FloatingActionButton absolutely to its first positioned parent element.\n       * * `fixed` (Default)&mdash;Positions the FloatingActionButton relative to the viewport. It always stays in the same place even if the page is scrolled.\n       */\n      this.positionMode = 'fixed';\n      /**\n       * Specifies the animation settings of the FloatingActionButton dial items.\n       * ([see example]({% slug dialitems_floatingactionbutton %}#toc-animation)).\n       *\n       * The possible values are:\n       * * Boolean\n       *    * (Default) `true`&mdash;Applies the default [`DialItemAnimation`]({% slug api_buttons_dialitemanimation %}) settings.\n       *    * `false`\n       * * `DialItemAnimation`\n       *    * `duration`&mdash;Specifies the animation duration in milliseconds for each dial item. Defaults to `180ms`.\n       *    * `gap`&mdash;Specifies the animation duration gap in milliseconds after each dial item is animated. Defaults to `90ms`.\n       */\n      this.dialItemAnimation = true;\n      /**\n       * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the FloatingActionButton.\n       */\n      this.tabIndex = 0;\n      /**\n       * Specifies the collection of the dial items that will be rendered in the FloatingActionButton popup.\n       */\n      this.dialItems = [];\n      /**\n       * Fires each time the FloatingActionButton gets blurred.\n       */\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the FloatingActionButton gets focused.\n       */\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time a dial item is clicked.\n       */\n      this.dialItemClick = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed\n       * ([more information and example]({% slug overview_floatingactionbutton %}#toc-events)).\n       */\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open\n       * ([more information and example]({% slug overview_floatingactionbutton %}#toc-events)).\n       */\n      this.close = new EventEmitter();\n      /**\n       * @hidden\n       */\n      this.id = `k-${guid()}`;\n      /**\n       * @hidden\n       */\n      this.dialListId = `k-dial-list-${guid()}`;\n      this._themeColor = DEFAULT_THEME_COLOR;\n      this._size = DEFAULT_SIZE;\n      this._rounded = DEFAULT_ROUNDED;\n      this._disabled = false;\n      this._align = {\n        horizontal: 'end',\n        vertical: 'bottom'\n      };\n      this._offset = {\n        x: DEFAULT_OFFSET,\n        y: DEFAULT_OFFSET\n      };\n      this.subscriptions = new Subscription();\n      this.rtl = false;\n      this.animationEnd = new EventEmitter();\n      this.initialSetup = true;\n      validatePackage(packageMetadata);\n      this.subscribeNavigationEvents();\n      this.subscriptions.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      }));\n    }\n    get fixedClass() {\n      return this.positionMode === 'fixed';\n    }\n    get absoluteClass() {\n      return this.positionMode === 'absolute';\n    }\n    /**\n     * Specifies the theme color of the FloatingActionButton\n     * ([see example]({% slug appearance_floatingactionbutton %}#toc-themeColor)).\n     * The theme color will be applied as background color of the component.\n     *\n     * The possible values are:\n     * * `primary` (Default)&mdash;Applies coloring based on the `primary` theme color.\n     * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n     * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n     * * `info`&mdash;Applies coloring based on the `info` theme color.\n     * * `success`&mdash; Applies coloring based on the `success` theme color.\n     * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n     * * `error`&mdash; Applies coloring based on the `error` theme color.\n     * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n     * * `light`&mdash; Applies coloring based on the `light` theme color.\n     * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n     * * `none`&mdash; Removes the built in theme color.\n     */\n    set themeColor(themeColor) {\n      const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;\n      this.handleClasses(newThemeColor, 'themeColor');\n      this._themeColor = newThemeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * Specifies the size of the FloatingActionButton\n     * ([see example]({% slug appearance_floatingactionbutton %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the FloatingActionButton.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `full` (default)\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Specifies whether the FloatingActionButton is disabled.\n     */\n    set disabled(disabled) {\n      this._disabled = disabled;\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Specifies the horizontal and vertical alignment of the FloatingActionButton\n     * ([see example]({% slug positioning_floatingactionbutton %}#toc-align)).\n     *\n     * The possible values are:\n     * * `{ horizontal: 'start'|'center'|'end', vertical: 'top'|'middle'|'bottom' }`\n     *\n     * The default value is:\n     * * `{ horizontal: 'end', vertical: 'bottom' }`\n     *\n     */\n    set align(align) {\n      this._align = Object.assign(this._align, align);\n    }\n    get align() {\n      return this._align;\n    }\n    /**\n     * Specifies the horizontal and vertical offset position of the FloatingActionButton\n     * ([see example]({% slug positioning_floatingactionbutton %}#toc-offset)).\n     *\n     * * The default value is:\n     * * `{ x: '16px', y: '16px' }`\n     */\n    set offset(offset) {\n      this._offset = Object.assign(this._offset, offset);\n      this.offsetStyles();\n    }\n    get offset() {\n      return this._offset;\n    }\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n      return this.disabled ? -1 : this.tabIndex;\n    }\n    ngAfterViewInit() {\n      ['size', 'rounded', 'themeColor'].forEach(option => this.handleClasses(this[option], option));\n      this.renderer.addClass(this.element.nativeElement, this.alignClass());\n      this.offsetStyles();\n      this.initialSetup = false;\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * Indicates whether the FloatingActionButton is currently open.\n     */\n    get isOpen() {\n      return isPresent(this.popupRef);\n    }\n    /**\n     * Focuses the FloatingActionButton.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the FloatingActionButton.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.blur();\n      }\n    }\n    /**\n     * Toggles the visibility of the FloatingActionButton dial items popup.\n     *\n     * If you use the `toggleDial` method to open or close the dial items,\n     * the `open` and `close` events do not fire ([more information and examples]({% slug openstate_floatingactionbutton %}#toc-events)).\n     *\n     * @param open - The state of dial items popup.\n     */\n    toggleDial(open) {\n      if (this.disabled || !this.hasDialItems) {\n        return;\n      }\n      const shouldOpen = isPresent(open) ? open : !this.isOpen;\n      if (this.disabled || shouldOpen === this.isOpen) {\n        return;\n      }\n      if (shouldOpen) {\n        setTimeout(() => this.openDial());\n      } else {\n        this.closeDial();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get ariaExpanded() {\n      return this.hasDialItems ? this.isOpen : null;\n    }\n    /**\n     * @hidden\n     */\n    get ariaHasPopup() {\n      return this.hasDialItems ? 'menu' : null;\n    }\n    /**\n     * @hidden\n     */\n    get ariaControls() {\n      return this.hasDialItems ? this.dialListId : null;\n    }\n    /**\n     * @hidden\n     */\n    get iconClasses() {\n      const classes = [];\n      if (this.iconClass) {\n        classes.push(`${this.iconClass}`);\n      }\n      if (this.icon) {\n        classes.push(`k-fab-icon k-icon k-i-${this.icon}`);\n      }\n      return classes;\n    }\n    /**\n     * @hidden\n     */\n    clickHandler() {\n      if (this.disabled || !this.hasDialItems) {\n        return;\n      }\n      this.ngZone.run(() => {\n        const shouldOpen = !this.isOpen;\n        this.toggleDialWithEvents(shouldOpen);\n      });\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(event) {\n      this.keyHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    keyHandler(event, keyEvent) {\n      if (this.disabled) {\n        return;\n      }\n      const focused = this.focusService.focused || 0;\n      const keyCode = event.keyCode;\n      const action = this.navigationService.process({\n        altKey: event.altKey,\n        current: focused,\n        keyCode,\n        keyEvent: keyEvent,\n        max: this.dialItems ? this.dialItems.length - 1 : 0,\n        min: 0,\n        flipNavigation: this.align.vertical === 'bottom'\n      });\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab) {\n        event.preventDefault();\n      }\n      if (action === NavigationAction.EnterUp && !this.hasDialItems) {\n        this.button.nativeElement.click();\n      } else if (action === NavigationAction.Open || action === NavigationAction.Close) {\n        const toggleDial = action === NavigationAction.Open;\n        this.ngZone.run(() => {\n          this.toggleDialWithEvents(toggleDial);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    onItemClick(event) {\n      const item = closest(event.target, '.k-fab-item');\n      if (!item) {\n        return;\n      }\n      const index = parseInt(item.getAttribute('data-fab-item-index'));\n      this.emitItemClick(index);\n    }\n    /**\n     * @hidden\n     */\n    focusHandler() {\n      if (!this.disabled) {\n        this.onFocus.emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n    blurHandler() {\n      this.onBlur.emit();\n      this.toggleDialWithEvents(false);\n    }\n    handleClasses(inputValue, input) {\n      if (isPresent(this.button) && (this[input] !== inputValue || this.initialSetup)) {\n        const button = this.button.nativeElement;\n        const classesToRemove = {\n          themeColor: `${FILLMODE_CLASS}-${this.themeColor}`,\n          size: SIZE_CLASSES[this.size],\n          rounded: ROUNDED_CLASSES[this.rounded]\n        };\n        const classesToAdd = {\n          themeColor: inputValue !== 'none' ? `${FILLMODE_CLASS}-${inputValue}` : '',\n          size: SIZE_CLASSES[inputValue],\n          rounded: ROUNDED_CLASSES[inputValue]\n        };\n        this.renderer.removeClass(button, classesToRemove[input]);\n        if (classesToAdd[input]) {\n          this.renderer.addClass(button, classesToAdd[input]);\n        }\n      }\n    }\n    onEnterPressed() {\n      const index = this.focusService.focused;\n      this.emitItemClick(index);\n    }\n    emitItemClick(index) {\n      const item = this.dialItems[index];\n      if (item && !item.disabled) {\n        const clickEventArgs = {\n          item: item,\n          index: index\n        };\n        this.dialItemClick.emit(clickEventArgs);\n        this.toggleDialWithEvents(false);\n        this.focusService.focused = index;\n      }\n    }\n    subscribeNavigationEvents() {\n      this.subscriptions.add(this.navigationService.navigate.subscribe(this.onArrowKeyNavigate.bind(this)));\n      this.subscriptions.add(this.navigationService.enter.subscribe(this.onNavigationEnterPress.bind(this)));\n      this.subscriptions.add(merge(this.navigationService.close, this.navigationService.esc).subscribe(this.onNavigationClose.bind(this)));\n    }\n    onArrowKeyNavigate({\n      index\n    }) {\n      this.focusService.focus(index);\n    }\n    onNavigationEnterPress() {\n      this.ngZone.run(() => {\n        if (this.isOpen) {\n          const focusedIndex = this.focusService.focused;\n          const focusedItem = this.dialItems[focusedIndex];\n          if (focusedItem && focusedItem.disabled) {\n            return;\n          }\n          if (isPresent(focusedIndex) && focusedIndex !== -1) {\n            this.onEnterPressed();\n            return;\n          }\n        }\n        if (!this.isOpen && isDocumentAvailable()) {\n          this.toggleDialWithEvents(true);\n          this.button.nativeElement.focus();\n        }\n      });\n    }\n    onNavigationClose() {\n      if (this.isOpen) {\n        this.ngZone.run(() => {\n          this.toggleDialWithEvents(false);\n          if (isDocumentAvailable()) {\n            this.button.nativeElement.focus();\n          }\n        });\n      }\n    }\n    alignClass() {\n      return `k-pos-${this.align.vertical}-${this.align.horizontal}`;\n    }\n    toggleDialWithEvents(open) {\n      if (open === this.isOpen) {\n        return;\n      }\n      const event = new PreventableEvent();\n      if (open) {\n        this.open.emit(event);\n      } else {\n        this.close.emit(event);\n      }\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      if (open) {\n        this.openDial();\n      } else {\n        this.closeDial();\n      }\n    }\n    openPopup() {\n      if (this.isOpen) {\n        return;\n      }\n      const isIconFab = this.icon && !this.text;\n      const rtl = this.rtl;\n      const align = this.align;\n      this.popupRef = this.popupService.open({\n        anchor: this.element.nativeElement,\n        animate: false,\n        content: this.popupTemplate,\n        anchorAlign: getAnchorAlign(align, rtl),\n        popupAlign: getPopupAlign(align, rtl),\n        popupClass: 'k-fab-popup k-popup-transparent'\n      });\n      const popupElement = this.popupRef.popupElement;\n      this.renderer.setStyle(popupElement, 'box-shadow', 'none');\n      if (isIconFab) {\n        this.subscriptions.add(this.popupRef.popupOpen.subscribe(() => this.positionPopup()));\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.popupMouseDownListener = this.renderer.listen(popupElement, 'mousedown', event => {\n          event.preventDefault();\n        });\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.toggleDialWithEvents(false));\n    }\n    closePopup() {\n      if (this.isOpen) {\n        if (this.popupMouseDownListener) {\n          this.popupMouseDownListener();\n        }\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    openDial() {\n      this.openPopup();\n      this.focusService.focus(0);\n      if (this.dialItemAnimation && this.isValidAnimation()) {\n        this.playAnimation(true);\n      }\n      this.renderer.setAttribute(this.button.nativeElement, 'aria-expanded', 'true');\n    }\n    closeDial() {\n      if (this.dialItemAnimation && this.isValidAnimation()) {\n        this.playAnimation(false);\n        this.animationEnd.pipe(take(1)).subscribe(() => this.closePopup());\n      } else {\n        this.closePopup();\n      }\n      this.renderer.setAttribute(this.button.nativeElement, 'aria-expanded', 'false');\n    }\n    isValidAnimation() {\n      const animation = this.dialItemAnimation;\n      if (typeof animation !== 'boolean') {\n        return animation.duration !== 0;\n      }\n      return true;\n    }\n    positionPopup() {\n      if (this.dialItemTemplate) {\n        return;\n      }\n      if (!this.popupRef) {\n        return;\n      }\n      const fab = this.element.nativeElement;\n      const fabWidth = fab.getBoundingClientRect().width;\n      const popupEl = this.popupRef.popupElement;\n      const icon = popupEl.querySelector('.k-fab-item-icon');\n      if (!icon) {\n        return;\n      }\n      const iconWidth = icon.getBoundingClientRect().width;\n      const left = fabWidth / 2 - iconWidth / 2;\n      const popupLeft = popupEl.getBoundingClientRect().left;\n      const isEndAlign = this.align.horizontal === 'end';\n      const leftValue = isEndAlign ? popupLeft - left : left + popupLeft;\n      const rtlLeftValue = isEndAlign ? left + popupLeft : popupLeft - left;\n      popupEl.style.left = this.rtl ? `${rtlLeftValue}px` : `${leftValue}px`;\n    }\n    offsetStyles() {\n      const hostElement = this.element.nativeElement;\n      this.renderer.setStyle(hostElement, this.horizontalPosition, this.horizontalOffset);\n      this.renderer.setStyle(hostElement, this.verticalPosition, this.verticalOffset);\n    }\n    get hasDialItems() {\n      return isPresent(this.dialItems) && this.dialItems.length !== 0;\n    }\n    /**\n     * Gets the CSS prop name of the selected vertical position (`top`/`bottom`);\n     */\n    get verticalPosition() {\n      return {\n        top: 'top',\n        middle: 'top',\n        bottom: 'bottom'\n      }[this.align.vertical];\n    }\n    /**\n     * Gets the offset according to the selected vertical position.\n     */\n    get verticalOffset() {\n      if (this.align.vertical === 'middle') {\n        return this.offset.y === DEFAULT_OFFSET ? '50%' : `calc(50% + ${this.offset.y})`;\n      }\n      return this.offset.y;\n    }\n    /**\n     * Gets the CSS prop name of the selected horizontal position (`left`/`right`);\n     */\n    get horizontalPosition() {\n      const {\n        horizontal\n      } = this.align;\n      return {\n        end: this.rtl ? 'left' : 'right',\n        center: 'left',\n        start: this.rtl ? 'right' : 'left'\n      }[horizontal];\n    }\n    /**\n     * Gets the offset according to the selected horizontal position.\n     */\n    get horizontalOffset() {\n      if (this.align.horizontal === 'center') {\n        return this.offset.x === DEFAULT_OFFSET ? '50%' : `calc(50% + ${this.offset.x})`;\n      }\n      return this.offset.x;\n    }\n    playerFor(element, animation) {\n      const factory = this.builder.build(animation);\n      return factory.create(element);\n    }\n    playAnimation(open) {\n      const durationSettings = this.durationSettings();\n      const animationSettings = {\n        duration: durationSettings.duration,\n        gap: durationSettings.gap,\n        align: this.align\n      };\n      const animation = open ? openAnimation(animationSettings) : closeAnimation(animationSettings);\n      let player = this.playerFor(this.popupRef.popupElement, animation);\n      player.play();\n      player.onDone(() => {\n        if (player) {\n          this.animationEnd.emit();\n          player.destroy();\n          player = null;\n        }\n      });\n    }\n    durationSettings() {\n      return {\n        duration: this.animationDuration(),\n        gap: this.animationGap()\n      };\n    }\n    animationGap() {\n      const animation = this.dialItemAnimation;\n      if (typeof animation !== 'boolean' && isPresent(animation.gap)) {\n        return animation.gap;\n      }\n      return DEFAULT_ITEM_GAP;\n    }\n    animationDuration() {\n      const animation = this.dialItemAnimation;\n      if (typeof animation !== 'boolean' && isPresent(animation.duration)) {\n        return animation.duration;\n      }\n      return DEFAULT_DURATION;\n    }\n  }\n  FloatingActionButtonComponent.ɵfac = function FloatingActionButtonComponent_Factory(t) {\n    return new (t || FloatingActionButtonComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3$1.PopupService), i0.ɵɵdirectiveInject(i4.AnimationBuilder), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n  FloatingActionButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FloatingActionButtonComponent,\n    selectors: [[\"kendo-floatingactionbutton\"]],\n    contentQueries: function FloatingActionButtonComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DialItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FloatingActionButtonTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialItemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fabTemplate = _t.first);\n      }\n    },\n    viewQuery: function FloatingActionButtonComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 7);\n        i0.ɵɵviewQuery(_c7, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.button = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function FloatingActionButtonComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-pos-fixed\", ctx.fixedClass)(\"k-pos-absolute\", ctx.absoluteClass);\n      }\n    },\n    inputs: {\n      themeColor: \"themeColor\",\n      size: \"size\",\n      rounded: \"rounded\",\n      disabled: \"disabled\",\n      align: \"align\",\n      offset: \"offset\",\n      positionMode: \"positionMode\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      buttonClass: \"buttonClass\",\n      dialClass: \"dialClass\",\n      text: \"text\",\n      dialItemAnimation: \"dialItemAnimation\",\n      tabIndex: \"tabIndex\",\n      dialItems: \"dialItems\"\n    },\n    outputs: {\n      onBlur: \"blur\",\n      onFocus: \"focus\",\n      dialItemClick: \"dialItemClick\",\n      open: \"open\",\n      close: \"close\"\n    },\n    features: [i0.ɵɵProvidersFeature([FocusService, NavigationService, NAVIGATION_SETTINGS_PROVIDER, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.floatingactionbutton'\n    }])],\n    decls: 6,\n    vars: 17,\n    consts: [[\"type\", \"button\", 1, \"k-fab\", \"k-fab-solid\", 3, \"tabIndex\", \"ngClass\", \"disabled\", \"kendoEventsOutsideAngular\", \"scope\", \"focus\", \"blur\"], [\"button\", \"\"], [4, \"ngIf\"], [\"popupTemplate\", \"\"], [3, \"ngTemplateOutlet\"], [\"innerCssClass\", \"k-fab-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-fab-text\", 4, \"ngIf\"], [\"innerCssClass\", \"k-fab-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-fab-text\"], [\"kendoDialList\", \"\", \"role\", \"menu\", 3, \"id\", \"ngClass\", \"dialItems\", \"dialItemTemplate\", \"align\", \"click\"]],\n    template: function FloatingActionButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"focus\", function FloatingActionButtonComponent_Template_button_focus_0_listener() {\n          return ctx.focusHandler();\n        })(\"blur\", function FloatingActionButtonComponent_Template_button_blur_0_listener() {\n          return ctx.blurHandler();\n        });\n        i0.ɵɵtemplate(2, FloatingActionButtonComponent_2_Template, 1, 1, null, 2);\n        i0.ɵɵtemplate(3, FloatingActionButtonComponent_ng_container_3_Template, 3, 2, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, FloatingActionButtonComponent_ng_template_4_Template, 1, 6, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabled);\n        i0.ɵɵproperty(\"tabIndex\", ctx.componentTabIndex)(\"ngClass\", ctx.buttonClass)(\"disabled\", ctx.disabled)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(14, _c15, ctx.keyDownHandler, ctx.clickHandler))(\"scope\", ctx);\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-disabled\", ctx.disabled)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-haspopup\", ctx.ariaHasPopup)(\"aria-controls\", ctx.ariaControls);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.fabTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.fabTemplate);\n      }\n    },\n    dependencies: [i2.IconWrapperComponent, DialListComponent, i3.NgClass, i9.EventsOutsideAngularDirective, i3.NgIf, i3.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return FloatingActionButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst exportedModules = [FloatingActionButtonComponent, DialItemTemplateDirective, FloatingActionButtonTemplateDirective];\nconst declarations = [...exportedModules, DialListComponent, DialItemComponent];\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the FloatingActionButton component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the FloatingActionButton module\n * import { FloatingActionButtonModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, FloatingActionButtonModule], // import FloatingActionButton module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * ```\n */\nlet FloatingActionButtonModule = /*#__PURE__*/(() => {\n  class FloatingActionButtonModule {}\n  FloatingActionButtonModule.ɵfac = function FloatingActionButtonModule_Factory(t) {\n    return new (t || FloatingActionButtonModule)();\n  };\n  FloatingActionButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FloatingActionButtonModule\n  });\n  FloatingActionButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, PopupModule, ListModule, EventsModule, IconsModule]]\n  });\n  return FloatingActionButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmodules'])\n * definition for the Buttons components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Buttons module\n * import { ButtonsModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ButtonsModule], // import Buttons module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet ButtonsModule = /*#__PURE__*/(() => {\n  class ButtonsModule {}\n  ButtonsModule.ɵfac = function ButtonsModule_Factory(t) {\n    return new (t || ButtonsModule)();\n  };\n  ButtonsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ButtonsModule\n  });\n  ButtonsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [ButtonGroupModule, ButtonModule, SplitButtonModule, DropDownButtonModule, ChipModule, FloatingActionButtonModule]\n  });\n  return ButtonsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ButtonComponent as Button, ButtonComponent, ButtonComponent as ButtonDirective, ButtonGroupComponent as ButtonGroup, ButtonGroupComponent, ButtonGroupModule, ButtonItemTemplateDirective, ButtonModule, ButtonsModule, ChipComponent, ChipListComponent, ChipModule, DialItemTemplateDirective, DropDownButtonComponent as DropDownButton, DropDownButtonComponent, DropDownButtonModule, FloatingActionButtonComponent, FloatingActionButtonModule, FloatingActionButtonTemplateDirective, FocusableDirective, ListComponent, ListModule, LocalizedSplitButtonMessagesDirective, PreventableEvent, SplitButtonComponent as SplitButton, SplitButtonComponent, SplitButtonCustomMessagesComponent, SplitButtonModule, TemplateContextDirective };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}